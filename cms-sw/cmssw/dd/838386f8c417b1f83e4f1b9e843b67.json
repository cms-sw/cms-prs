{"additions": 4673, "auther_ref": "switchProducer", "auther_sha": "6ea40f9516a8d1f9b9481a58fbf716c07a000455", "author": "makortel", "body": "This PR provides an implementation for a `SwitchProducer` to allow a runtime decision on which EDProducer from a given set to run for a given module label. The main use case in mind are heterogeneous/offloaded/accelerated algorithms, where we would run the accelerated EDProducer if the accelerator device is available in the system, and run the \"legacy\" CPU EDProducer otherwise.\r\n\r\nFor a given accelerator type, the generic `SwitchProducer` is supposed to be inherited along\r\n```python\r\ndef _switch_foo():\r\n    return (isFooDeviceEnabled(), 2)\r\n\r\nclass SwitchProducerFoo(cms.SwitchProducer):\r\n    def __init__(self, **kargs):\r\n        super(SwitchProducerFoo,self).__init__(\r\n            dict(cpu = SwitchProducer.getCpu(),\r\n                 foo = _switch_foo),\r\n            **kargs\r\n        )\r\n```\r\nHere the deriving class provides a dictionary of possible cases along with functions that return a `(bool, int)` tuple. The `bool` tells whether that device type is enabled on the machine, and the `int` gives a priority of that device wrt. other devices. `SwitchProducer.getCpu()` returns a function for the CPU (always enabled, priority `1`). Note that in order to be able to pickle the configuration, these functions have to be at (python) module level (i.e. e.g. lambdas or static methods are not sufficient).\r\n\r\nThe decision logic chooses the case that has the largest priority among those that are enabled. The decision is made at the point where the python configuration is transformed for C++, i.e. in case of production at the worker node.\r\n\r\nThe switch decision does not affect the configuration hash, meaning that the framework will consider a run/lumi/event produced with `isFooDeviceEnabled() == False` the same as with `True`.\r\n\r\nThe concrete `SwitchProducerFoo` would then be used along (e.g. in a `cfi` file)\r\n```python\r\nbar = SwitchProducerFoo(\r\n    cpu = cms.EDProducer(\"Bar\", ...),\r\n    foo = cms.EDProducer(\"BarOnFooDevice\", ...)\r\n)\r\n```\r\nIn this example, if `isFooDeviceEnabled()` returns\r\n* `True` => `BarOnFooDevice` EDProducer is run\r\n* `False` => `Bar` EDProducer is run\r\n\r\nThe switched EDProducers are required to declare exactly the same products with the `produces()` call.\r\n\r\nWhen a client asks for a products if `bar`, it will get pointed to the exactly the same `edm::Wrapper` that contains the product by the chosen EDProducer. The additional \"layer' is, however, tracked in provenance, such that the parent of a product `bar` is `bar@cpu` or `bar@foo`, depending which one of the EDProducers was run.\r\n\r\nThe python interface is likely to evolve with more experience with it, with accelerated EDProducers, and with devices beyond CUDA. Note that this PR adds only the generic infrastructure, a CUDA-specific implementation will follow in a separate PR (or e.g. as part of the effort of #25353).\r\n\r\nTested in 10_4_0_pre3, no changes expected.", "branch": "master", "changed_files": 31, "comments": 3, "commits": 3, "created_at": "1544129379", "deletions": 11, "labels": ["code-checks-approved", "comparison-pending", "core-pending", "orp-pending", "pending-signatures", "tests-pending"], "milestone": "CMSSW_10_4_X", "number": 25439, "release-notes": [], "review_comments": 0, "state": "open", "title": "Add SwitchProducer mechanism to allow runtime decision which algorithm implementation to run", "updated_at": "1544130167", "user": "makortel"}