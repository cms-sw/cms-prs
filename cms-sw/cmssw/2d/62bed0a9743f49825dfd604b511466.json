{"additions": 1026, "auther_ref": "asynchronousESProducer3", "auther_sha": "19f9c5f7bba1d4dad988bbebdf6b4b74c2961aaa", "author": "wddgit", "body": "#### PR description:\r\n\r\nImplement ExternalWork for ESProducers\r\n\r\nThis new feature is analogous to the ExternalWork ability already implemented for EDProducers and EDFilters. It behaves in almost the same way. There is an acquire function that runs that can get data from the EventSetup, then the ExternalWork runs asynchronously, and finally a produce method runs. The ExternalWork has a WaitingTaskWithArenaHolder to let the produce method know when it can start. It is important that the acquire method completes and is no longer on the stack while the ExternalWork is running.\r\n\r\nThe interface to use this feature is provided by a new base class named ESProducerExternalWork that derives from the ESProducer class. It has new functions named setWhatAcquiredProduced (6 functions with this name) and setWhatAcquiredProducedWithLambda (2 functions with this name). To utilize the new feature, use one of the new functions instead of one of the old functions named setWhatProduced. The new acquire function must be provided to the ESProducerExternalWork in a way completely analogous to the way one supplies the produce function, with all the same alternatives. If a class has multiple produce methods, some can use the new interface and some can use the existing interface which is unchanged.\r\n\r\nFor example, one could define the following function as a member function of the class deriving from ESProducerExternalWork.\r\n\r\n```\r\nvoid acquire(MyRecordType const&, edm::WaitingTaskWithArenaHolder);\r\n```\r\n\r\nOr one could provide a lambda as an argument to the function call. Or one could define a similar function with a different name and provide a pointer to that function as an argument to the function. \r\n\r\nThe behavior of existing code that uses the older setWhatProduced functions should not change. That interface is not modified, although there are some changes in the underlying implementation details.\r\n\r\n@fwyzard This adds two new signals to the ActivityRegistry that you might or might not want to include in the fast timer service.\r\n\r\n(This is my second attempt at this. See #40798 for the first attempt and review comments. Since that attempt I refactored the Callback class to 3 classes, CallbackBase, CallBack, and CallbackExternalWork and refactored ESProducer into 2 separate classes ESProducer and ESProducerExternalWork. The code moved around so much it seemed easier to start with a fresh PR. I extended the new test so that the test ESProducer has two \"produce\" functions, one with an acquire function and one without. In terms of behavior and interface, nothing important changed other than ESProducers using the new feature should inherit from ESProducerExternalWork instead of ESProducer.)\r\n\r\nWe discussed an additional feature that was related to the acquire function returning a value other than void. We decided to postpone that development for a separate PR to be submitted later.\r\n\r\n#### PR validation:\r\n\r\nAt this point nothing uses this new feature other than new unit tests in the Framework added by this PR. These new unit tests pass. Existing code should behave identically so this relies on existing tests for ESProducers not using using the new ExternalWork feature.\r\n", "branch": "master", "changed_files": 28, "comments": 25, "commits": 18, "created_at": "1678309523", "deletions": 278, "labels": ["core-pending", "pending-signatures", "tests-pending", "orp-pending", "code-checks-approved"], "milestone": "CMSSW_13_1_X", "number": 41001, "release-notes": [], "review_comments": 55, "state": "open", "title": "Implement ExternalWork for ESProducers", "updated_at": "1679426037", "user": "wddgit"}