{"additions": 3, "auther_ref": "fix-base-class-order", "auther_sha": "c069cbfcd2125e4ac475d91405af2b0faa0ca3bb", "author": "davidlt", "body": "In CMSSW with ICC 17.0 Beta we have a number of edmWriteConfigs\nsegfaults.\n\nInteresting files are these (in order):\n- DataFormats/GeometrySurface/interface/ReferenceCounted.h\n- DataFormats/GeometrySurface/interface/Surface.h\n- DataFormats/GeometrySurface/interface/Plane.h\n- DataFormats/GeometrySurface/interface/BoundDisk.h\n- TrackingTools/GeomPropagators/src/TrackerBounds.cc\n\n`TrackerBounds.cc` contains static `ReferenceCountingPointer` which are\nconstructer at `dlopen()` time. These are basically\n`boost::intrusive_ptr`.\n\nWe have:\n\n```\n\n  Disk   \n\n     \n     \n\n  Plane  \n\n     \n     \n\n Surface \n\n     \n     \n     \n                                                  \n                                                  \n  \n  GloballyPositioned<float>       ReferenceCountedInConditions   \n                                  (is a BasicReferenceCounted)   \n  \n                                                   \n                                                   \n                                                   \n                          \n                          BasicReferenceCounted is responsible for \n                          keeping reference count and destroying   \n                          object once reference count drops to     \n                          zero. Simply put handles                 \n                          boost::intrusive_ptr.                    \n                          \n```\n\nNote that `Surface` has multiple inheritance and\n`ReferenceCountedInConditions` is the second in base class list.\n\nThe way C++ works:\n- `Disk`, `Plane`, `Surface`, `GloballyPositioned<float>` will have the\n  same `this` pointer.\n- `ReferenceCountedInConditions` will at specific delta from previous\n  `this`, i.e. its `this` pointer does not point to `Disk` object, but to\n  some location in `Disk` allocation.\n\nNow then time comes to destroy `Disk` object via `boost::intrusive_ptr`\nmechanism we will be providing a wrong address to `free()`:\n\n```\nInvalid free() / delete / delete[] / realloc()\n   at 0x4029134: operator delete(void*) (in /cvmfs/cms-ib.cern.ch/2016-20/slc6_amd64_gcc530/external/valgrind/3.11.0/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n   by 0xFA29809: BasicReferenceCounted::removeReference() const (ReferenceCounted.h:48)\n   by 0xFA28FDC: intrusive_ptr_release(BasicReferenceCounted const*) (ReferenceCounted.h:86)\n   by 0xFA3AB60: boost::intrusive_ptr<Disk>::~intrusive_ptr() (intrusive_ptr.hpp:97)\n   by 0xFA3AB7B: boost::intrusive_ptr<Disk>::~intrusive_ptr() (intrusive_ptr.hpp:95)\n   by 0xFA3A0F9: ReferenceCountingPointer<Disk>::~ReferenceCountingPointer() (ReferenceCounted.h:63)\n   by 0x70BBB21: exit (in /lib64/libc-2.12.so)\n   by 0x70A4D63: (below main) (in /lib64/libc-2.12.so)\n Address 0x2e4c4798 is 8 bytes inside a block of size 128 alloc'd\n   at 0x4028108: operator new(unsigned long) (in /cvmfs/cms-ib.cern.ch/2016-20/slc6_amd64_gcc530/external/valgrind/3.11.0/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n   by 0xFA39D3F: _INTERNAL_105__mnt_build_davidlt_CMSSW_8_1_ICC_X_2016_05_09_2300_src_TrackingTools_GeomPropagators_src_TrackerBounds_cc_f6781c7c::initPositive() (TrackerBounds.cc:35)\n   by 0xFA3A014: __sti___ZN13TrackerBounds15thePositiveDiskE (TrackerBounds.cc:49)\n   by 0xFA39FB9: __sti__$E (TrackerBounds.cc:47)\n   by 0x400E66E: call_init (dl-init.c:85)\n   by 0x400E66E: _dl_init (dl-init.c:134)\n   by 0x4012DC4: dl_open_worker (dl-open.c:496)\n   by 0x400E285: _dl_catch_error (dl-error.c:178)\n   by 0x4012599: _dl_open (dl-open.c:587)\n   by 0x6643F65: dlopen_doit (in /lib64/libdl-2.12.so)\n   by 0x400E285: _dl_catch_error (dl-error.c:178)\n   by 0x664429B: _dlerror_run (in /lib64/libdl-2.12.so)\n   by 0x6643EE0: dlopen@@GLIBC_2.2.5 (in /lib64/libdl-2.12.so)\n```\n\nThen our memory allocation will fail:\n\n```\n*** glibc detected *** edmWriteConfigs: free(): invalid pointer: 0x0000000004893e38 ***\n```\n\nIf we make `ReferenceCountedInConditions` the first in base class it, it\nwill have a matching `this` pointer to `Disk` object being created.\n\nSigned-off-by: David Abdurachmanov David.Abdurachmanov@cern.ch\n", "branch": "CMSSW_8_1_X", "changed_files": 2, "closed_at": "1463242234", "comments": 12, "commits": 2, "created_at": "1462962469", "deletions": 2, "labels": ["comparison-available", "orp-pending", "pending-signatures", "reconstruction-approved", "simulation-pending", "tests-approved"], "merge_commit_sha": "a54895c53480324e49c84650e0ccb117bf90bbc7", "merged_at": "1463242234", "merged_by": "davidlange6", "milestone": "Next CMSSW_8_1_X", "number": 14452, "release-notes": [], "review_comments": 0, "state": "closed", "title": "ReferenceCounted* must always be the first in base class list", "updated_at": "1463242234", "user": "davidlt"}