{"additions": 173, "auther_ref": "alpakaReducedEventSynchronize", "auther_sha": "c237b97148ebfe1fe7e3402566b5930e3730a0f2", "author": "makortel", "body": "#### PR description:\r\n\r\nPrompted by https://github.com/cms-sw/cmssw/issues/44769#issuecomment-2067257800 this PR reduces the amount of blocking `alpaka::wait()` calls (leading to `cudaEventSynchronize()` on NVIDIA GPU) via the EDMetadata destructor. To check the impact I used the reproducer https://github.com/cms-sw/cmssw/issues/44769 (even if it eventually leads to an assertion failure). Initially the reproducer lead to 2470 calls to `cudaEventSynchronize()`.\r\n\r\nThe first commit avoids calling `alpaka::wait()` in `EDProducer::produce()` when no asynchronous work was launched (possible async work is identified by the use of `device::Event::queue()` in any way, including consuming a device side data product). In this case there is no need to synchronize the device and host. This commit reduced the number of `cudaEventSynchronize()` calls to 2284 (-7.5 %).\r\n\r\nThe second commit caches the alpaka::Event completion, so that `alpaka::wait()` does not need to be called again on an already-completed alpaka Event. This commit reduced the number of `cudaEventSynchronize()` calls to 2019 (-40 % wrt the starting point).\r\n\r\nThe third commit avoids calling `alpaka::wait()` on the destructor of an `EDMetadata` when the Queue of the `EDMetadata` object has been re-used by another `EDMedata` (in a `EDProducer::produce()` that consumed the device-side data product holding the first `EDMedata` object). Since the only purpose of the `alpaka::wait()` in the `~EDMetadata()` is to ensure all asynchronous work of an edm::Event has completed before the edm::Stream moves to the next edm::Event, for any Queue it is enough to `wait()` on the alpaka::Event that was last recorded on that Queue. This commit reduced the number of `cudaEventSynchronize()` calls to 1462 (-18 % wrt the starting point).\r\n\r\nThere is one case left (on purpose) where the `EDProducer::produce()` still calls `alpaka::wait()`. This happens when the `produce()` launches asynchronous work (i.e. calls `device::Event::queue()`), but does not produce any device-side data products. I can't imagine a good use case for such an EDProducer (except maybe a DQM-style module, but that would need a separate module base class in any case that could then deal with the necessary edm::Event-level synchronization \r\n\r\nI don't expect a huge impact from the reduction of these calls, as in the present cases in HLT the alpaka::Events should have completed by the time the `alpaka::wait()` is called. The stack traces in https://github.com/cms-sw/cmssw/issues/44769#issuecomment-2066613569 nevertheless show the `cudaEventSynchronize()` acquiring a lock even when the CUDA event is complete, so at least this PR should reduce the contention on that lock.\r\n\r\n#### PR validation:\r\n\r\n`HeterogeneousCore/Alpaka{Core,Test}` unit tests pass. \r\n\r\n#### If this PR is a backport please specify the original PR and why you need to backport that PR. If this PR will be backported please specify to which release cycle the backport is meant for:\r\n\r\nLikely will be backported to 14_0_X", "branch": "master", "changed_files": 12, "comments": 1, "commits": 3, "created_at": "1713973690", "deletions": 10, "labels": ["pending-signatures", "tests-pending", "orp-pending", "code-checks-pending", "heterogeneous-pending"], "milestone": "CMSSW_14_1_X", "number": 44841, "release-notes": [], "review_comments": 0, "state": "open", "title": "Reduce Alpaka event synchronization calls via EDMetadata", "updated_at": "1713973719", "user": "makortel"}