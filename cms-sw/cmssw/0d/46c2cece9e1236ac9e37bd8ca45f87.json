{"additions": 346, "auther_ref": "alpakaModuleTypeResolver", "auther_sha": "48ef682809158a0557f0b1aa09afe094e35df99e", "author": "makortel", "body": "#### PR description:\r\n\r\nThis PR enables the \"alternative module loading\" functionality for Alpaka modules (following what I presented in https://indico.cern.ch/event/1208060/#16-portable-configuration-with). In order to use this mechanism, the configuration needs to load `HeterogeneousCore.AlpakaCore.ProcessAcceleratorAlpaka_cfi`, and define the modules in the configuration with `@alpaka` postfix in the type name along\r\n```py\r\n# selects at run time whether alpaka_serial_sync::FooProducer or alpaka_cuda_async::FooProducer is used\r\nprocess.foo = cms.EDProducer(\"FooProducer@alpaka\", ...)\r\n```\r\nThe syntax works for EDProducers, EDAnalyzers, EDFilters, and ESProducers.\r\n\r\nThe backend can also be set explicitly via\r\n```\r\nprocess.foo = cms.EDProducer(\"FooProducer@alpaka\",\r\n    ...,\r\n    alpaka = cms.untracked.PSet(\r\n        backend = cms.untracked.string(\"serial_sync\") # or cuda_async\r\n    )\r\n)\r\n```\r\nThe validity of the explicitly chosen backend is checked at the time the configuration is processed at the worker node, and value that is incompatible with the node hardware (or `process.options.accelerators`) leads to an exception being thrown. It follows that this approach of defining Alpaka modules with explicitly selected backend does not really work with `SwitchProducer` (where all modules need to be constructed in the C++ side).\r\n\r\nAn alternative design that was considered was to encode the backend selection information in the C++ type field (e.g. after `@alpaka`). Expressing it in the configuration parameters instead allows the backend selection to be easily customized after the module definition (e.g. with a `Modifier`), and allows the selection logic to be extended with little technical constraints in the future (e.g. selected modules could use TBB when running on CPU). \r\n\r\nThe benefits of this model over `SwitchProducer` include\r\n* works also with `SCRAM_ARCH`s that don't support all accelerator backends (or anything beyond CPU)\r\n* works also for `EDAnalyzer`, `EDFilter`, and `ESProducer` in addition of `EDProducer`\r\n* reduces the duplication of module parameters (at least in simple cases)\r\n* allows all module member functions (including constructors) to use backend device specific functionality without any explicit checks about \"if the backend is enabled\"\r\n\r\n\r\n##### Potential discussion points\r\n\r\n* The nomenclature for declaring \"Alpaka modules\" with `@alpaka` suffix\r\n* The nomenclature for setting the module's backend explicitly\r\n* Whether the backend selection PSet should be visible in the generated `cfi` file (and thus be visible for ConfDB parsing)\r\n* For what exactly the `cfi` files should be generated?\r\n   * This PR takes a perhaps too big step of generating `cfi` file only for `FooProducer@alpaka`. An alternative could be to generate `cfi` files also for `serial_sync::FooProducer` and `cuda_async::FooProducer` for some amount of time.\r\n* When to add the loading of `HeterogeneousCore.AlpakaCore.ProcessAcceleratorAlpaka_cfi` to `Configuration.StandardSequences.Accelerators_cff`\r\n\r\n#### PR validation:\r\n\r\nUnit tests run.", "branch": "master", "changed_files": 17, "comments": 5, "commits": 3, "created_at": "1674088001", "deletions": 52, "labels": ["core-pending", "pending-signatures", "orp-pending", "tests-started", "code-checks-approved", "heterogeneous-pending"], "milestone": "CMSSW_13_0_X", "number": 40564, "release-notes": [], "review_comments": 0, "state": "open", "title": "Enable \"alternative module loading\" approach for Alpaka modules", "updated_at": "1674088956", "user": "makortel"}