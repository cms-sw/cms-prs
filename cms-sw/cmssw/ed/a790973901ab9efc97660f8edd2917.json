{"additions": 197, "auther_ref": "dqm-add-dqm-dataformat", "auther_sha": "5594491afb30a0caca6542f9da62b6564ef8985a", "author": "schneiml", "body": "We plan to revise major parts of the DQM infrastructure code in the coming months. One part of this is switching from a central, `edm::Service` based store to an EDProduct based architecture. This will not bring major changes to subsystem code, the `DQMStore` _threaded_ mode isolated and prevented interaction between modules already in the last years, and the required handling of EDProducts will be handled internally, leaving the main APIs of `DQMStore` unchanged.\r\n\r\nThis PR proposes a data format to represent DQM data in EDM. A number of design decisions and questions are discussed in the comments. So far no code using these products exists; this PR is not supposed to be merged (though it should not break anything), but to get feedback on the design of the products to get this right before we start heavily relying on it.\r\n\r\n#### Additional comments:\r\n\r\nOne crucial part is to only *move* TH1 objects into the product after they are completely filled, and only allowing read-only access to them afterwards. That should prevent the need for locking [1]. However, then it is crucial that the products are destroyed deterministically to not inflate memory usage too much. *Recycling* the objects after the product was destroyed would be elegant but seems dangerous and complicated. \r\n\r\nAnother big question is the handling of MEs that cover more than one lumisection, but less than a run. They could be kept as a set of MEs inside a run product (this seems like the logically right thing to do to me), but that would require keeping multiple copies of each ME in memory, which would be problematic if applied to the majority of MEs. Therefore, it might be better to put these into a lumi product every few lumisections, but that logically does not make much sense when read back into a process. We could work around that in `DQMStore` and our I/O modules, but maybe there is a better way.\r\n\r\nFor the merging, I assumed we'd just use the framework functionality, it seems to be well thought through. Not sure how that will interact with our own IO modules (which do the merging right now).\r\n\r\nFinally, we need to decide if this should be a transient product (that would be completely sufficient for now) or allow it to be persistent. I'd favour the latter, if it does not come with too many contraints.\r\n\r\n[1] I am afraid certain operations on ROOT objects that look like reading actually modify state, but I hope that is documented correctly by `const`-ness.\r\n\r\n@Dr15Jones @makortel (and anybody else interested) hoping for some comments of yours.", "branch": "master", "changed_files": 3, "closed_at": "1560260799", "comments": 7, "commits": 1, "created_at": "1556869029", "deletions": 0, "labels": ["code-checks-approved", "comparison-pending", "core-pending", "dqm-pending", "orp-pending", "pending-signatures", "tests-pending"], "milestone": "CMSSW_11_0_X", "number": 26603, "release-notes": [], "review_comments": 1, "state": "closed", "title": "[RFC] A DataFormat for DQM Data", "updated_at": "1560260799", "user": "schneiml"}