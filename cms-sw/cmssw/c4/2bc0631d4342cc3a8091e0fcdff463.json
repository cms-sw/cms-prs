{"additions": 941, "auther_ref": "alpakaDeviceCache", "auther_sha": "11a42bf1865e062896e15b453e907cab90685b30", "author": "makortel", "body": "#### PR description:\r\n\r\n##### `CopyToDeviceCache<T>`\r\n\r\nThe primary purpose of this PR is to add `CopyToDeviceCache<T>` class template, that allows copying \"arbitrary data\" to all devices of a backend within an EDProducer (e.g. in a constructor or `initializeGlobalCache()`. The use case is to avoid (mis)using EventSetup for the purposes of copying EDProducer configuration parameters to the devices, following the discussion in https://github.com/cms-sw/cmssw/pull/43130#discussion_r1382478241. The `CopyToDeviceCache` relies on the specializations `CopyToDevice<T>` to deduce the corresponding device-side data type, and to do the actual copy. The copy is done synchronously in the object constructor.\r\n\r\nFor testing purposes I wanted to use Alpaka buffers, so I added partial specializations of `CopyToDevice<T>` for 0- and 1-dimensional Alpaka buffers.\r\n\r\n##### `moveToDeviceAsync()`\r\n\r\n`CopyToDeviceCache<T>` copies the object also for the host backends. In order to get some feeling what it would mean to avoid that copy, I explored first similar shortcut for the simpler case of doing it for one device e.g. in `EDProducer::produce()` body (effectively addressing https://github.com/cms-sw/cmssw/issues/43796#issuecomment-1912011782). I took the approach of exploring if the \"move concept\" could be used (which came up as an idea in some earlier discussion with @fwyzard). This lead to `moveToDeviceAsync()` function. For host backends it just moves the argument object, and for non-host backends it uses the `CopyToDevice<T>` to deduce the corresponding device-side type, and to copy the data. Also in the non-host backend case the argument object is moved-from, so any use of the argument object in the caller will result a \"use after move\" (whatever that behavior then is for the object). \r\n\r\nI think the result is not too bad. However, given that Alpaka buffers behave like `std::shared_ptr`, I decided to require the host-side type to be non-copyable in order to be even remotely sure that the data of the moved-in host object would not be used (mostly written into) in the host code concurrently to the asynchronous copy to the device. I was concerned that otherwise the following kind of mistake would be too easy to do\r\n```c++\r\nHostBuffer h_buf;\r\nfill(h_buf);\r\nHostBuffer h_buf2 = h_buf; // h_buf2 points to the same host memory as h_buf\r\nDeviceBuffer d_buf = moveToDeviceAsync(queue, std::move(h_buf));\r\nalpaka::wait(queue);\r\nfill(h_buf2); // on host backend would modify the same memory as h_buf!\r\n``` \r\nThe function can be easily used with `PortableHostCollection<T>` and `PortableHostObject<T>` as they explicitly disable copying (for similar reasons).\r\n\r\n##### `MoveToDeviceCache<T>`\r\n\r\n`MoveToDeviceCache<T>` combines the \"copy to all devices\" aspect of `CopyToDeviceCache<T>` with the move semantics and \"`T` must be non-copyable\" requirement of `moveToDeviceAsync()`.\r\n\r\nGiven that the only difference of `MoveToDeviceCache<T>` and `CopyToDeviceCache<T>` is the behavior of the constructor, an alternative could be to have a single class, where the desired behavior would be selected e.g. with an explicit tag argument. Theoretically one could implement copy and move constructors such that the object is \"moved\" when possible and otherwise copied, but I though maybe we'd want to explicitly specify the desired behavior (copy vs move on host) to catch cases where a data type becomes accidentally copyable (leading to slower code path on host).\r\n\r\n##### Allow contained object of `PortableHostObject<T>` to be initialized in the constructor\r\n\r\nWhile crafting tests for the earlier cases I came to wonder if it would make sense to allow the contained object of `PortableHostObject<T>` (i.e. `T`) to be initialized directly in the `PortableHostObject<T>` constructor, rather than always having to first create the `PortableHostObject<T>`, and then fill the content. This could be particularly useful when constructing `MoveToDeviceCache<PortableHostObject<T>>` in the EDProducer initialization list. I added additional constructors that use placement `new`, and added a requirement that the `T` must be trivially destructible.\r\n\r\n#### PR validation:\r\n\r\nUnit tests run.", "branch": "master", "changed_files": 16, "comments": 10, "commits": 7, "created_at": "1707945467", "deletions": 4, "labels": ["pending-signatures", "tests-approved", "orp-pending", "code-checks-approved", "heterogeneous-pending"], "milestone": "CMSSW_14_2_X", "number": 43969, "release-notes": [], "review_comments": 2, "state": "open", "title": "[RFC] Add {Copy,Move}ToDeviceCache<T> class templates and moveToDeviceAsync function template", "updated_at": "1725349298", "user": "makortel"}