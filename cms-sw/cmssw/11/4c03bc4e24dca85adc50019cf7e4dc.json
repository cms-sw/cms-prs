{"additions": 2, "auther_ref": "dqm-fix-asserlegacysafe-in-configbuilder", "auther_sha": "35ad7e23b5232941dca4a737a5750506f1647c24", "author": "schneiml", "body": "#### PR description:\r\n\r\nThis prevents the crashes in 1361.181 reported in #28622. Prevents, not fixes.\r\n\r\nI'd like to summon @Dr15Jones and @makortel to this discussion: What happens here is that a job with VALIDATION enabled (which I am pretty sure does contain some `edm::EDAnalyzer`s -- I have not checked it though) is requested to run with concurrent lumisections. EDM should prevent this, since it is not safe to have concurrent lumisections with legacy modules [1]. However, the new `DQMStore` still detects that a new lumisection starts before the previous one is saved, and that consequently it needs to copy MEs (this triggers the `assertLegacySafe` assertion by default, unless it is explicitly turned off). The problem with that is now that `edm::EDAnalyzer` based DQM code could hold pointers that get `free`'d by the `DQMStore` later (as the first lumisection ends). For this reason, it is only safe to disable `assertLegacySafe` when there are no `edm::EDAnalyzer` based `DQMStore` users in the process.\r\n\r\nSo, with this PR, 1361.181 runs but is unsafe. What we should do instead is either make sure that EDM actually does not use concurrent lumisections at all [2] when there are legacy modules (then we can keep the assertion enabled and it will not fire), or remove all legacy modules from the jobs using concurrent lumis (that is really what we need to do, but much harder than it sounds).\r\n\r\nWe can of course also just keep the unsafe behaviour. It seems to work for now (maybe because the legacy modules involved don't do anything dangerous [3]), but I can't make any guarantees about that.\r\n\r\n[1] actually, the majority of DQM currently runs in `edm::one::EDProducer`s watching lumis which should cause the same effect.\r\n[2] I *think* EDM might overlap writing the current lumi and processing the next even when there are modules blocking concurrent lumis -- that would explain the behaviour.\r\n[3] (Edit:) Since this entire story is about lumis, but legacy modules by default deal with per-job MEs, we should actually be safe as long as the legacy modules don't explicitly use `Scope::LUMI`. But then the (meaningful) legacy plugins *do* actually set a scope different from `JOB` manually (else they would not produce any output in the reco step), and *technically* the same problem exists with `RUN` MEs. Except, we don't do anything close to concurrent runs currently. But, we have reasons to believe that there is no risk of use-after-free in this workflow today.\r\n\r\n#### PR validation:\r\n```\r\nrunTheMatrix.py  -l 1361.181  -i all --job-reports -t 4\r\n```\r\npasses. Note the `-t 4`, bare `1361.181` did not trigger the problem.\r\n\r\nSee concerns above.\r\n\r\n", "branch": "master", "changed_files": 1, "closed_at": "1584348782", "comments": 57, "commits": 1, "created_at": "1581424512", "deletions": 0, "labels": ["code-checks-approved", "comparison-available", "fully-signed", "operations-approved", "orp-approved", "tests-approved", "urgent"], "merge_commit_sha": "d8696a82eab0f6f265cae146c6be3794b71d6582", "merged_at": "1584348782", "merged_by": "cmsbuild", "milestone": "CMSSW_11_1_X", "number": 28920, "release-notes": [], "review_comments": 0, "state": "closed", "title": "DQM: Disable assertLegacySafe when concurrent lumis are enabled.", "updated_at": "1584348782", "user": "schneiml"}