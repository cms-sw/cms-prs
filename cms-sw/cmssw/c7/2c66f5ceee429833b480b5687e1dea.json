{"additions": 414, "auther_ref": "cluster-EventAuxiliary3", "auther_sha": "be3bf3ebb571e1db4bfc491484e0ab4936711a7a", "author": "dan131riley", "body": "#### PR description:\r\n\r\nWhen removal of duplicate events and fast cloning are enabled (the current defaults), the input module reads the entire EventAuxiliary branch when it opens a file in order to check for duplicates and determine if fast cloning is possible. This currently results in many small reads scattered throughout the entire file, which is not a good IO pattern for storage systems optimized for large-block throughput. In some cases large files cannot be served from some sites, see\r\n\r\nhttps://hypernews.cern.ch/HyperNews/CMS/get/edmFramework/3853/1/1/1/1.html\r\n\r\nThis PR delays writing the EventAuxiliary branch until the file close sequence, with the branch stored entirely in large baskets near the end of the file that can be read in a few operations.  No other changes in output are expected.  The EventAuxiliary data are stored in a more compact form that splits the data into a set that change every event in one structure, and pieces that change infrequently or repeat frequently in two other data structures with references from the main data structure.\r\n\r\nThis version is also configurable, so the current behavior can be selected if the increased memory usage is problematic for some workflows.\r\n\r\n#### PR validation:\r\n\r\nA standard \"limited\" matrix was run with no unexpected failures.  Individual EventAuxiliary records were dumped in input and output files to verify there were no differences, and I wrote a unit test.\r\n\r\nTo examine memory usage, I ran on 1,000,000 empty events.  This yields a somewhat optimistic estimate since there is no variation in the slowly varying pieces, where in real data the ProcessGUIDs can vary frequently.  Old vs. new memory reports for 1,000,000 empty events with standard cmsRun:\r\n```\r\nMemoryCheck: module PoolOutputModule:output VSIZE 351.328 0 RSS 126.988 0.027343\r\nMemoryCheck: module PoolOutputModule:output VSIZE 457.34  0 RSS 166.613 0.257812\r\n```\r\nand with cmsRunGlibC\r\n```\r\nMemoryCheck: module PoolOutputModule:output VSIZE 327.637 0 RSS 119.84 0.0273438\r\nMemoryCheck: module PoolOutputModule:output VSIZE 375.387 0 RSS 165.223 0.257812\r\n```\r\nRSS increases by around 40-50MB (much better than the previous version in #25994).  The large VSIZE increase with the standard cmsRun is due to jemalloc's \"slash and burn\" approach to address space usage; when reading real data with no event selection, this PR tries to mitigate the frequent reallocations by pre-reserving for the number of events in each new input file.\r\n\r\nCopying a real data file with 110474 events and 84505 unique ProcessGUIDs, reading from a file written by this PR adds around 10MB to the RSS, likely due to the larger ROOT buffers for the larger baskets (I added a maximum basket size in order to limit this increase).  Writing the file with this PR adds another 30-50 MB to RSS, but actually reduces VSIZE due to fewer memory allocations for the EventAuxiliary records from the input file.\r\n\r\nIf this memory usage is still unacceptable, the next thing to try would be simply raising the initial basket size for the branch.\r\n", "branch": "master", "changed_files": 10, "closed_at": "1614413109", "comments": 33, "commits": 13, "created_at": "1595958448", "deletions": 14, "labels": ["code-checks-approved", "core-approved", "fully-signed", "orp-approved", "tests-rejected"], "merge_commit_sha": "f027a97fcb207e618e6dcc5148197d0ba7b5f268", "merged_at": "1614413109", "merged_by": "cmsbuild", "milestone": "CMSSW_11_3_X", "number": 30949, "release-notes": [], "review_comments": 10, "state": "closed", "title": "Delay writing the EventAuxiliary branch to file closing", "updated_at": "1614413109", "user": "dan131riley"}