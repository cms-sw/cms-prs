{"additions": 207, "auther_ref": "mm_dev_beamSpotCheckImprovements", "auther_sha": "4fc1b570c3b0a5448cc82cbe3ef76f5892848820", "author": "mmusich", "body": "#### PR description:\r\n\r\nThis PR is a follow-up to PR https://github.com/cms-sw/cmssw/pull/45589 and https://github.com/cms-sw/cmssw/pull/47044, introducing several improvements.\r\nProfiting of the operational experience in 2025 from the tracker alignment group, this PR introduces the following:\r\n  * add support for `BeamSpotTransientObjectsRcd`\r\n  * improve readability of the outputs;\r\n  * improve variable naming and usage in test configurations;\r\n  * add a conditional `fillDescriptions` to `BeamSpotCompatibilityChecker` to take the \"event Beam Spot\" either from the `EventSetup` or the `Event`;\r\n  * in `Alignment/OfflineConfiguration` configuration files take by default the \"DB Beam Spot\" from the `Event` (via `BeamSpotProducer`) \r\n     * in the PV-related configurations, move  `BeamSpotCompatibilityChecker` after the track refit sequence (to avoid framework deadlocks when taking the Beam Spot from the `Event`).\r\n\r\n#### PR validation:\r\n\r\nRun the packages unit tests with: `scram b runtests` and obtained the following:\r\n\r\n```console\r\nPass   93s ... Alignment/OfflineValidation/validateAlignments\r\nPass  119s ... Alignment/OfflineValidation/DMRall\r\nPass   22s ... Alignment/OfflineValidation/DiElectronVertex\r\nPass   59s ... Alignment/OfflineValidation/DiMuonVall\r\nPass   15s ... Alignment/OfflineValidation/DiMuonVertex\r\nPass   89s ... Alignment/OfflineValidation/EoP\r\nPass  294s ... Alignment/OfflineValidation/GCPall\r\nPass   82s ... Alignment/OfflineValidation/Genericall\r\nPass   72s ... Alignment/OfflineValidation/JetHTall\r\nPass  120s ... Alignment/OfflineValidation/MTSall\r\nPass  253s ... Alignment/OfflineValidation/Miscellanea\r\nPass   62s ... Alignment/OfflineValidation/PVall\r\nPass   17s ... Alignment/OfflineValidation/PixBaryall\r\nPass  206s ... Alignment/OfflineValidation/PrimaryVertex\r\nPass   91s ... Alignment/OfflineValidation/SagittaBiasNtuplizer\r\nPass   68s ... Alignment/OfflineValidation/SplitVall\r\nPass   52s ... Alignment/OfflineValidation/SubmitPVrbr\r\nPass  124s ... Alignment/OfflineValidation/SubmitPVsplit\r\nPass  101s ... Alignment/OfflineValidation/Zmumuall\r\nPass    4s ... Alignment/OfflineValidation/testDiMuonBiasesPlotting\r\nPass    2s ... Alignment/OfflineValidation/testEoPPlotting\r\nPass    3s ... Alignment/OfflineValidation/testPVPlotting\r\nPass    1s ... Alignment/OfflineValidation/testTkAlStyle\r\nPass  217s ... Alignment/OfflineValidation/testTrackAnalysis\r\nSkip    0s ... RecoVertex/BeamSpotProducer/beamfit (Disabled via BuildFile)\r\nPass    2s ... RecoVertex/BeamSpotProducer/testBeamSpotAnalyzer\r\nPass    0s ... RecoVertex/BeamSpotProducer/testBeamSpotCompatibility\r\nPass   21s ... RecoVertex/BeamSpotProducer/testBeamSpotCompatibilityEventData\r\nPass    4s ... RecoVertex/BeamSpotProducer/testReadWriteBSFromDB\r\n```\r\n\r\nIn addition I have run the following script with `cmsRun PV_cfg.py config=validation.json` in a variety of settings to make sure the results are as expected.\r\n\r\n<details>\r\n\r\n<summary> Scripts used for cross-checks </summary>\r\n\r\n### PV_cfg.py\r\n\r\n```python\r\nimport FWCore.ParameterSet.Config as cms\r\nimport FWCore.PythonUtilities.LumiList as LumiList\r\nfrom Alignment.OfflineValidation.TkAlAllInOneTool.defaultInputFiles_cff import filesDefaultData_HLTPhys2024I\r\n\r\nfrom FWCore.ParameterSet.VarParsing import VarParsing\r\n\r\nfrom Alignment.OfflineValidation.TkAlAllInOneTool.utils import _byteify\r\nimport json\r\nimport os\r\n\r\n##Define process\r\nimport FWCore.ParameterSet.Config as cms\r\nfrom Configuration.Eras.Era_Run3_2025_cff import Run3_2025\r\nprocess = cms.Process('PrimaryVertexValidation',Run3_2025)\r\n\r\n##Argument parsing\r\noptions = VarParsing()\r\noptions.register(\"config\", \"\", VarParsing.multiplicity.singleton, VarParsing.varType.string , \"AllInOne config\")\r\n\r\noptions.parseArguments()\r\n\r\n##Read in AllInOne config in JSON format\r\nif options.config == \"\":\r\n    config = {\"validation\": {},\r\n              \"alignment\": {}}\r\nelse:\r\n    with open(options.config, \"r\") as configFile:\r\n        config = json.load(configFile)\r\n\r\nisDA = config[\"validation\"].get(\"isda\", True)\r\nisMC = config[\"validation\"].get(\"ismc\", True)\r\n\r\nrunboundary = config[\"validation\"].get(\"runboundary\", 1)\r\n\r\n##Read filenames from given TXT file and define input source\r\nreadFiles = []\r\n\r\nif \"dataset\" in config[\"validation\"]:\r\n    with open(config[\"validation\"][\"dataset\"], \"r\") as datafiles:\r\n        for fileName in datafiles.readlines():\r\n            readFiles.append(fileName.replace(\"\\n\", \"\"))\r\n\r\n    process.source = cms.Source(\"PoolSource\",\r\n                                fileNames = cms.untracked.vstring(readFiles),\r\n                                skipEvents = cms.untracked.uint32(0)\r\n                            )\r\nelse:\r\n    print(\">>>>>>>>>> PV_cfg.py: msg%-i: config not specified! Loading default dataset -> filesDefaultData_HLTPhys2024I!\")\r\n    process.source = cms.Source(\"PoolSource\",\r\n                                fileNames = filesDefaultData_HLTPhys2024I,\r\n                                skipEvents = cms.untracked.uint32(0)\r\n                            )\r\n\r\n##Get good lumi section and load data or handle MC\r\nif \"goodlumi\" in config[\"validation\"]:\r\n    if os.path.isfile(config[\"validation\"][\"goodlumi\"]):\r\n        goodLumiSecs = cms.untracked.VLuminosityBlockRange(LumiList.LumiList(filename = config[\"validation\"][\"goodlumi\"]).getCMSSWString().split(','))\r\n        \r\n    else:\r\n        print(\"Does not exist: {}. Continue without good lumi section file.\")\r\n        goodLumiSecs = cms.untracked.VLuminosityBlockRange()\r\n\r\nelse:\r\n    goodLumiSecs = cms.untracked.VLuminosityBlockRange()\r\n\r\nif isMC:\r\n     print(\">>>>>>>>>> PV_cfg.py: msg%-i: This is simulation!\")\r\n     runboundary = 1\r\nelse:\r\n     process.source.lumisToProcess = goodLumiSecs\r\n\r\nisMultipleRuns=False\r\nif(isinstance(runboundary, (list, tuple))):\r\n     isMultipleRuns=True\r\n     print(\"Multiple Runs are selected\")       \r\nif(isMultipleRuns):\r\n     process.source.firstRun = cms.untracked.uint32(runboundary[0])\r\nelse:\r\n     process.source.firstRun = cms.untracked.uint32(runboundary)\r\n\r\n##default set to 1 for unit tests\r\nprocess.maxEvents = cms.untracked.PSet(input = cms.untracked.int32(config[\"validation\"].get(\"maxevents\", 1)))\r\n\r\n##Bookeeping\r\nprocess.options = cms.untracked.PSet(\r\n   wantSummary = cms.untracked.bool(False),\r\n   Rethrow = cms.untracked.vstring(\"ProductNotFound\"),\r\n   fileMode  =  cms.untracked.string('NOMERGE'),\r\n)\r\n\r\nprocess.load(\"FWCore.MessageLogger.MessageLogger_cfi\")\r\nprocess.MessageLogger = cms.Service(\"MessageLogger\",\r\n                                    destinations   = cms.untracked.vstring('cerr'),\r\n                                    cerr       = cms.untracked.PSet(threshold = cms.untracked.string('INFO'))\r\n                                   )\r\n\r\n##Basic modules\r\nprocess.load(\"RecoVertex.BeamSpotProducer.BeamSpot_cff\")\r\nprocess.load(\"Configuration.Geometry.GeometryRecoDB_cff\") #or process.load(\"Configuration.Geometry.GeometryDB_cff\")?????\r\nprocess.load('Configuration.StandardSequences.Services_cff')\r\nprocess.load(\"Configuration.StandardSequences.MagneticField_cff\")\r\n\r\n####################################################################\r\n# Produce the Transient Track Record in the event\r\n####################################################################\r\nprocess.load(\"TrackingTools.TransientTrack.TransientTrackBuilder_cfi\")\r\n\r\n####################################################################\r\n# Load and Configure Common Track Selection and refitting sequence\r\n####################################################################\r\nimport Alignment.CommonAlignment.tools.trackselectionRefitting as trackselRefit\r\nprocess.seqTrackselRefit = trackselRefit.getSequence(process,\r\n                                                     config[\"validation\"].get(\"trackcollection\", \"ALCARECOTkAlMinBias\"),\r\n                                                     isPVValidation=True,\r\n                                                     TTRHBuilder=config[\"validation\"].get(\"tthrbuilder\", \"WithAngleAndTemplate\"),\r\n                                                     usePixelQualityFlag=config[\"validation\"].get(\"usePixelQualityFlag\", True),\r\n                                                     openMassWindow=False,\r\n                                                     cosmicsDecoMode=True,\r\n                                                     cosmicsZeroTesla=config[\"validation\"].get(\"cosmicsZeroTesla\", False),                                                     \r\n                                                     momentumConstraint=None,\r\n                                                     cosmicTrackSplitting=False,\r\n                                                     use_d0cut=False,\r\n                                                     )\r\n\r\n#Global tag\r\nprocess.load(\"Configuration.StandardSequences.FrontierConditions_GlobalTag_cff\")\r\nfrom Configuration.AlCa.GlobalTag import GlobalTag\r\nprocess.GlobalTag = GlobalTag(process.GlobalTag, config[\"alignment\"].get(\"globaltag\", \"140X_dataRun3_Prompt_v4\"))\r\n\r\n##Load conditions if wished\r\nif \"conditions\" in config[\"alignment\"]:\r\n    from CalibTracker.Configuration.Common.PoolDBESSource_cfi import poolDBESSource\r\n\r\n    for condition in config[\"alignment\"][\"conditions\"]:\r\n        setattr(process, \"conditionsIn{}\".format(condition), poolDBESSource.clone(\r\n             connect = cms.string(str(config[\"alignment\"][\"conditions\"][condition][\"connect\"])),\r\n             toGet = cms.VPSet(\r\n                        cms.PSet(\r\n                                 record = cms.string(str(condition)),\r\n                                 tag = cms.string(str(config[\"alignment\"][\"conditions\"][condition][\"tag\"]))\r\n                        )\r\n                     )\r\n            )\r\n        )\r\n\r\n        setattr(process, \"prefer_conditionsIn{}\".format(condition), cms.ESPrefer(\"PoolDBESSource\", \"conditionsIn{}\".format(condition)))\r\n\r\n####################################################################\r\n# Load and Configure event selection\r\n####################################################################\r\nprocess.primaryVertexFilter = cms.EDFilter(\"VertexSelector\",\r\n                                           src = cms.InputTag(config[\"validation\"].get(\"vertexcollection\", \"offlinePrimaryVertices\")),\r\n                                           cut = cms.string(\"!isFake && ndof > 4 && abs(z) <= 24 && position.Rho <= 2\"),\r\n                                           filter = cms.bool(True)\r\n                                           )\r\n\r\nprocess.noscraping = cms.EDFilter(\"FilterOutScraping\",\r\n                                  applyfilter = cms.untracked.bool(True),\r\n                                  src = cms.untracked.InputTag(config[\"validation\"].get(\"trackcollection\", \"ALCARECOTkAlMinBias\")),\r\n                                  debugOn = cms.untracked.bool(False),\r\n                                  numtrack = cms.untracked.uint32(10),\r\n                                  thresh = cms.untracked.double(0.25)\r\n                                  )\r\n\r\n###################################################################\r\n# Beamspot compatibility check\r\n###################################################################\r\n#from RecoVertex.BeamSpotProducer.beamSpotCompatibilityChecker_cfi import beamSpotCompatibilityChecker\r\n#process.BeamSpotChecker = beamSpotCompatibilityChecker.clone(\r\nprocess.BeamSpotChecker = cms.EDAnalyzer('BeamSpotCompatibilityChecker',   \r\n    #bsFromFile = config[\"validation\"].get(\"bsFromFile\",\"offlineBeamSpot::RECO\"),  # source of the event beamspot (in the ALCARECO files)\r\n    bsFromFile = cms.InputTag(config[\"validation\"].get(\"bsFromFile\",\"hltOnlineBeamSpot::HLT\")),  # source of the event beamspot (in the ALCARECO files)\r\n    bsFromDB = cms.InputTag(\"offlineBeamSpot::@currentProcess\"), # source of the DB beamspot (from Global Tag) NOTE: only if dbFromEvent is True!\r\n    #bsFromDB = cms.InputTag(\"offlineBeamSpot::pippo\"), # source of the DB beamspot (from Global Tag) NOTE: only if dbFromEvent is True!\r\n    dbFromEvent = cms.bool(True),    \r\n    warningThr = cms.double(config[\"validation\"].get(\"bsIncompatibleWarnThresh\", 3)), # significance threshold to emit a warning message\r\n    errorThr = cms.double(config[\"validation\"].get(\"bsIncompatibleErrThresh\", 5)),    # significance threshold to abort the job\r\n    verbose = cms.untracked.bool(False)\r\n)\r\n\r\nprocess.load(\"Alignment.CommonAlignment.filterOutLowPt_cfi\")\r\nprocess.filterOutLowPt.src = cms.untracked.InputTag(config[\"validation\"].get(\"trackcollection\", \"ALCARECOTkAlMinBias\"))\r\nprocess.filterOutLowPt.ptmin = cms.untracked.double(config[\"validation\"].get(\"ptCut\", 3.))\r\nprocess.filterOutLowPt.runControl = False\r\nif(isMultipleRuns):\r\n     process.filterOutLowPt.runControlNumber.extend((runboundary))\r\nelse:\r\n     process.filterOutLowPt.runControlNumber = [runboundary]\r\n\r\nif isMC:\r\n     process.goodvertexSkim = cms.Sequence(process.noscraping + process.filterOutLowPt)\r\nelse:\r\n     process.goodvertexSkim = cms.Sequence(process.primaryVertexFilter + process.noscraping + process.filterOutLowPt)\r\n\r\n\r\n####################################################################\r\n# Imports of parameters\r\n####################################################################\r\nfrom RecoVertex.PrimaryVertexProducer.OfflinePrimaryVertices_cfi import offlinePrimaryVertices\r\n## modify the parameters which differ\r\nFilteringParams = offlinePrimaryVertices.TkFilterParameters.clone(\r\n     maxNormalizedChi2 = 5.0,  # chi2ndof < 5\r\n     maxD0Significance = 5.0,  # fake cut (requiring 1 PXB hit)\r\n     maxEta = 5.0,             # as per recommendation in PR #18330\r\n)\r\n\r\n## MM 04.05.2017 (use settings as in: https://github.com/cms-sw/cmssw/pull/18330)\r\nfrom RecoVertex.PrimaryVertexProducer.OfflinePrimaryVertices_cfi import DA_vectParameters\r\nDAClusterizationParams = DA_vectParameters.clone()\r\n\r\nGapClusterizationParams = cms.PSet(algorithm   = cms.string('gap'),\r\n                                   TkGapClusParameters = cms.PSet(zSeparation = cms.double(0.2))  # 0.2 cm max separation betw. clusters\r\n                                   )\r\n\r\n####################################################################\r\n# Deterministic annealing clustering or Gap clustering\r\n####################################################################\r\ndef switchClusterizerParameters(da):\r\n     if da:\r\n          print(\">>>>>>>>>> testPVValidation_cfg.py: msg%-i: Running DA Algorithm!\")\r\n          return DAClusterizationParams\r\n     else:\r\n          print(\">>>>>>>>>> testPVValidation_cfg.py: msg%-i: Running GAP Algorithm!\")\r\n          return GapClusterizationParams\r\n\r\n####################################################################\r\n# Configure the PVValidation Analyzer module\r\n####################################################################\r\nfrom Alignment.OfflineValidation.primaryVertexValidation_cfi import primaryVertexValidation  as _primaryVertexValidation\r\nprocess.PVValidation = _primaryVertexValidation.clone(\r\n    TrackCollectionTag = \"FinalTrackRefitter\",\r\n    VertexCollectionTag = config[\"validation\"].get(\"vertexcollection\", \"offlinePrimaryVertices\"),\r\n    Debug = False,\r\n    storeNtuple = False,\r\n    useTracksFromRecoVtx = False,\r\n    isLightNtuple = True,\r\n    askFirstLayerHit = False,\r\n    forceBeamSpot = config[\"validation\"].get(\"forceBeamSpot\", False),\r\n    probePt = config[\"validation\"].get(\"ptCut\", 3),\r\n    probeEta  = config[\"validation\"].get(\"etaCut\", 2.5),\r\n    minPt  = config[\"validation\"].get(\"minPt\", 1.),\r\n    maxPt  = config[\"validation\"].get(\"maxPt\", 30.),\r\n    doBPix = config[\"validation\"].get(\"doBPix\", True),\r\n    doFPix = config[\"validation\"].get(\"doFPix\", True),\r\n    numberOfBins = config[\"validation\"].get(\"numberOfBins\", 48),\r\n    runControl = config[\"validation\"].get(\"runControl\", False),\r\n    runControlNumber = [runboundary],\r\n    TkFilterParameters = FilteringParams,\r\n    TkClusParameters = switchClusterizerParameters(isDA)\r\n)\r\n\r\n####################################################################\r\n# Output file\r\n####################################################################\r\nprocess.TFileService = cms.Service(\"TFileService\",\r\n            fileName = cms.string(\"{}/PVValidation_{}_{}.root\".format(config.get(\"output\", os.getcwd()), config[\"alignment\"].get(\"name\", \"\"), config[\"validation\"].get(\"IOV\", 1.))),\r\n            closeFileFast = cms.untracked.bool(True),\r\n    )\r\n\r\n\r\nprocess.load(\"RecoVertex.BeamSpotProducer.BeamSpotOnline_cfi\")\r\nfrom RecoVertex.BeamSpotProducer.BeamSpotOnline_cfi import onlineBeamSpotProducer as _onlineBeamSpotProducer\r\nprocess.offlineBeamSpot = _onlineBeamSpotProducer.clone()\r\n\r\n####################################################################\r\n# Path\r\n####################################################################\r\nprocess.p = cms.Path(process.goodvertexSkim*\r\n                     process.seqTrackselRefit*\r\n                     process.BeamSpotChecker*\r\n                     process.PVValidation)\r\n\r\nprint(\"Done\")\r\n```\r\n\r\n### validation.json\r\n\r\n```json\r\n{\r\n    \"output\": \".\",\r\n    \"alignment\": {\r\n        \"color\": 1,\r\n        \"style\": 1,\r\n        \"globaltag\": \"150X_dataRun3_HLT_v1\",\r\n        \"title\": \"HLT GT\",\r\n        \"name\": \"GT\"\r\n    },\r\n    \"validation\": {\r\n        \"maxevents\": 100,\r\n        \"isda\": true,\r\n        \"ismc\": false,\r\n        \"vertexcollection\": \"offlinePrimaryVertices\",\r\n        \"trackcollection\": \"hltMergedTracks\",\r\n        \"tthrbuilder\": \"WithTrackAngle\",\r\n        \"usePixelQualityFlag\": false,\r\n        \"IOV\": 1,\r\n        \"dataset\": \"/afs/cern.ch/cms/CAF/CMSALCA/ALCA_TRACKERALIGN/data/commonValidation/alignmentObjects/hpeterse/13p6TeVCommissioning/filelists/HLTMonitor_Run2025B-Express-v1_FEVTHLTALL/HLTMonitor_Run2025B-Express-v1_FEVTHLTALL_since391884.txt\",\r\n        \"goodlumi\": \"/afs/cern.ch/cms/CAF/CMSALCA/ALCA_TRACKERALIGN/MP/MPproduction/datasetfiles/Collisions2025/120525/Collisions25_13p6TeV_391658_391953_DCSOnly_TkPx.json\"\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n\r\n#### If this PR is a backport please specify the original PR and why you need to backport that PR. If this PR will be backported please specify to which release cycle the backport is meant for:\r\n\r\nNot a backport, will be backported to CMSSW_15_0_X for 2025 data-taking operations.", "branch": "master", "changed_files": 17, "comments": 7, "commits": 7, "created_at": "1747475309", "deletions": 116, "labels": ["reconstruction-pending", "dqm-pending", "alca-pending", "db-pending", "pending-signatures", "tests-pending", "orp-pending", "code-checks-approved", "tracking", "trk"], "milestone": "CMSSW_15_1_X", "number": 48111, "release-notes": [], "review_comments": 0, "state": "open", "title": "Improve `BeamSpotCompatibilityChecker` and its usage in `Alignment/OfflineValidation`", "updated_at": "1747490715", "user": "mmusich"}