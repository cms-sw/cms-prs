{"additions": 119, "auther_ref": "alpakaCachingAllocatorFreeException", "auther_sha": "eb061c622457c88e321f2be66afa397178d6d2c6", "author": "makortel", "body": "#### PR description:\r\n\r\nhttps://github.com/cms-sw/cmssw/issues/44634 reported an HLT job failure caused by an illegal memory access on a GPU. The failure was reported as a crash instead of a caught exception because of a second exception being thrown from `CachingAllocator<T>::free()` by `alpaka::enqueue()` when objects using cached allocations were being deleted as part of the stack unwinding of the original exception.\r\n\r\nThe `alpaka::enqueue()` is used in `CachingAllocator<T>::free()` to \"record\" the alpaka Event in the Queue when the freed memory block is supposed to be recached. This PR changes the behavior such that if `alpaka::enqueue()` throws an exception, the memory block is treated as freed instead of recached.\r\n\r\nI checked the alpaka Buffers, Queues, and Events that their destructors do not throw exceptions, but report any errors from the underlying APIs as printouts.\r\n\r\n#### PR validation:\r\n\r\nI tested the reproducer in https://github.com/cms-sw/cmssw/issues/44634 on a GPU node with `CUDA_LAUNCH_BLOCKING=1 cmsRun ...`, and now the job reports the exception in a useful way\r\n```\r\n----- Begin Fatal Exception 05-Apr-2024 20:44:47 CEST-----------------------\r\nAn exception of category 'StdException' occurred while\r\n   [0] Processing  Event run: 378940 lumi: 21 event: 5339574 stream: 0\r\n   [1] Running path 'DST_PFScouting_JetHT_v1'\r\n   [2] Calling method for module PFClusterSoAProducer@alpaka/'hltParticleFlowClusterHBHESoA'\r\nException Message:\r\nA std::exception was thrown.\r\n/cvmfs/cms.cern.ch/el8_amd64_gcc12/external/alpaka/1.1.0-c6af69ddd6f2ee5be4f2b069590bae19/include/alpaka/kernel/TaskKernelGpuUniformCudaHipRt.hpp(259) 'TApi::setDevice(queue.m_spQueueImpl->m_dev.getNativeHandle())' A previous API call (not this one) set the error  : 'cudaErrorIllegalAddress': 'an illegal memory access was encountered'!\r\n----- End Fatal Exception -------------------------------------------------\r\n```\r\n\r\nAfterwards the job still crashes, but in direct CUDA code (`cms::cuda::abortOnCudaError()` in `SiPixelGainCalibrationForHLTGPU::~SiPixelGainCalibrationForHLTGPU()`), but that is probably not worth of addressing at this time, when the direct CUDA code is expected to be removed later on.\r\n\r\nWithout `CUDA_LAUNCH_BLOCKING=1` the reported exception message is no longer useful, but at least the job contains printouts from Alpaka code that include the `cudaErrorIllegalAddress` error name. So while not ideal, the log contains more useful information than before this PR.\r\n\r\nThe added unit test succeeds on Serial and CUDA backends (and without the change of this PR the unit test fails on CUDA backend, and succeeds on Serial backend).\r\n\r\n#### If this PR is a backport please specify the original PR and why you need to backport that PR. If this PR will be backported please specify to which release cycle the backport is meant for:\r\n\r\nTo be backported to 14_0_X", "branch": "master", "changed_files": 3, "comments": 15, "commits": 1, "created_at": "1712937996", "deletions": 1, "labels": ["pending-signatures", "tests-approved", "orp-pending", "code-checks-approved", "heterogeneous-pending"], "milestone": "CMSSW_14_1_X", "number": 44730, "release-notes": [], "review_comments": 1, "state": "open", "title": "Ignore errors from `alpaka::enqueue()` in `CachingAllocator::free()`", "updated_at": "1713289007", "user": "makortel"}