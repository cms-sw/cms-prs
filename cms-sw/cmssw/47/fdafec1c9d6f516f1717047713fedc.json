{"additions": 4506, "auther_ref": "tracker_traits_125", "auther_sha": "345af0a89bc4540ab898b4f318ff31f1a73d5f3f", "author": "AdrianoDee", "body": "This PR proposes the addition of a `TrackerTraits` template parameter for all the modules and the datastructres used for pixel tracks reconstruciton. This trait holds all the methods and constants needed to define the pixel tracker topology. Being a template, this would allow to define different datastructure sizes, selection algorithms, fitting features for the whole chain at compile time. In this way one could keep disentangled the different conditions and reconstuction targets (HLT, offline, HIon, Run3, Phase2 ...).\r\n\r\nWith the implementation of such a structure this PR allows to run on GPU (and CPU) the whole Phase2 Inner Tracker reconstruction (from DIGI to pixel Tracks). A following PR will allow this also for offline pixel seeding and offline HIon pixel track reconstruction. \r\n\r\nFind below some comments to the code to (I hope) better navigate it, the validation for run3 pixel tracks w.r.t. to `12_5_X` as it is and the performance for Phase2 IT reconstruction. Few open points are still to be addressed but I would leave them documented in an issue and to be assessed in following PRs.\r\n\r\n- [ ] better tuning for Phase2 layer pairs selection: high impact on timing; \r\n- [ ] better tuning for Phase2 High Purity selection;\r\n- [ ] extending the TrackerTraits logic to few RawToDigi methods (such as `clusterChargeCut`, `calibDigisPhase2` ...);\r\n- [x] address CPUvsGPU discrepancies for Phase2;\r\n- [ ] add validation scripts for Phase2 IT reco (local reco and pixel track reco);\r\n- [x] tuning pixel vertex reconstruction (n.b. in the TDR the legacy one was used);\r\n- [] update Riemann fit also (needed? not actually used in production);\r\n- [ ] updating DQM modules such as `SiPixelPhase1CompareTrackSoA` to be runnable also for Phase2.\r\n\r\nThis PR also answers the comments that were left on https://github.com/cms-sw/cmssw/pull/36235 and corrects the pixel digis calibration on gpu (in `gpuCalibPixel.h`) to reproduce what is in `PixelThresholdClusterizer.cc`. This implies changes in the constants to be used moved to\r\n\r\n```Cpp\r\n constexpr float ElectronPerADCGain = 1500;\r\n constexpr uint16_t Phase2DigiBaseline = 1000;\r\n```\r\n\r\nand in `Phase2KinkADC` usage in the calibration. See the original algorithm (in [PixelThresholdClusterizer](https://cmssdt.cern.ch/dxr/CMSSW/source/RecoLocalTracker/SiPixelClusterizer/plugins/PixelThresholdClusterizer.cc#338)) and the parameter sets used (in [phase2TrackerDigitizer_cfi](https://cmssdt.cern.ch/dxr/CMSSW/source/SimTracker/SiPhase2Digitizer/python/phase2TrackerDigitizer_cfi.py#3) and [SiPixelClusterizer_cfi](https://cmssdt.cern.ch/dxr/CMSSW/source/RecoLocalTracker/SiPixelClusterizer/python/SiPixelClusterizer_cfi.py#33))\r\n## Code comments\r\n\r\n### \"Backward\" compatibility\r\n\r\nWhen trying to run on Run3 `RAW` files on which the new `HLT` step has been run (from `12_3_X` on) some ROOT dictionary error shows up (see below for a link to a sample log). Having tried the usual class versioning instructions (and the CMS_CLASS_VERSION tool) and being unsuccessful I've found a workaround to: \r\n\r\n1. avoid making useless all the samples already produced for Run3 since the HLT integration; \r\n2. avoid adding an explicit drop for pixel tracks productes in the RECO step, that seems unreasonable to me;\r\n\r\nI've linked [here](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/dictionary_errors/) the errors I refer to that happens if I simply redefine the class with the new `TrackerTraits`.\r\n \r\nSo, the basic idea is to keep the former `CUDADataFormats` classes as they where (namely `TrackingRecHit2DHeterogeneous` and `TrackSoAHeterogeneousT`) and to rename the new classes.\r\n\r\nSo, .e.g., for `TrackSoAHeterogeneousT` one would keep the class as it is (even if dummy)\r\n\r\n```Cpp\r\ntemplate <int32_t S>\r\n class TrackSoAHeterogeneousT\r\n\r\n```\r\n\r\nAnd have a new `PixelTrackSoAT` whose behaviour is based on the `TrackerTraits` logic.\r\n\r\n```Cpp\r\ntemplate <typename TrackerTraits>\r\n class PixelTrackSoAT : public TrackSoAHeterogeneousT<TrackerTraits::maxNumberOfTuples> \r\n```\r\n\r\nNote that this kind of issues appears also simply when updating these numbers here\r\n\r\n```Cpp\r\nnamespace pixelTrack {\r\n\r\n #ifdef GPU_SMALL_EVENTS\r\n  // kept for testing and debugging\r\n  constexpr uint32_t maxNumber() { return 2 * 1024; }\r\n#else\r\n  // tested on MC events with 55-75 pileup events\r\n  constexpr uint32_t maxNumber() { return 32 * 1024; }\r\n#endif\r\n\r\n```\r\n\r\nThat would change the size of the SoA (anyway needed at one point).\r\n\r\nThe same logic applies, for `TrackingRecHit2DHeterogeneous`.\r\n\r\n\r\n```Cpp\r\ntemplate <typename Traits>\r\n class TrackingRecHit2DHeterogeneous {\r\n public:\r\n   CMS_CLASS_VERSION(10);\r\n };\r\n```\r\n\r\nWhere the legacy class name is kept as it is to allow ROOT dictionary to find it.\r\n\r\nComments are very welcome! I understand that this is ... ugly and most probably at one point it will fade out but this is the best way I found at the moment to satisfy both 1. and 2..\r\n\r\n### Partial specialization\r\n\r\nThis is a common \"feature\" of `TrackingRecHit2DHeterogeneousT` and  `CAHitNtupletGeneratorKernels` that are the two modules that where already templated with `CPU\\GPU\\Host` traits. So in order to keep (since it's useful both for specializing and readability) the same syntax used before, i.e. having e.g. `TrackingRecHit2DCPU` and `TrackingRecHit2DGPU`, one would need to parially specialize the two classes. Now this would be possible but in our case we have a lot of stuff in common (trivially the constructors) so would make much more sense to partially specialize the single methods. But this is not possible. One must specialize the whole class for a method to be specialized. So this means that simply having an alias such as\r\n\r\n```Cpp\r\ntemplate <typename TrackerTraits>\r\nusing TrackingRecHit2DGPUT = TrackingRecHit2DHeterogeneousT<cms::cudacompat::GPUTraits, TrackerTraits>;\r\n```\r\n\r\nwould end up in the `invalid use of incomplete type` error. \r\n\r\nThe alternative would be to have the whole class specialized. But this would mean we need\r\nto rewrite every method (specialzed don't see primary methods). Thus this is overcome with inheritance and with this workaround, i.e. using inheritance+specialization, we keep under control code duplication. This means to have the real class defined in:\r\n\r\n```Cpp\r\ntemplate <typename Traits, typename TrackerTraits>\r\nclass TrackingRecHit2DHeterogeneousT\r\n```\r\n\r\nHavin then a \"Base class (better naming maybe would help) that inherits from it:\r\n\r\ntemplate <typename Traits, typename TrackerTraits>\r\nclass TrackingRecHit2DGPUBaseT : public TrackingRecHit2DHeterogeneousT<cms::cudacompat::GPUTraits, TrackerTraits> {};\r\n\r\nfor each `Trait`, that furtherly may be specialized to keep only the `TrackerTraits` template\r\n\r\n```Cpp\r\ntemplate <typename TrackerTraits>\r\nclass TrackingRecHit2DGPUBaseT<cms::cudacompat::GPUTraits, TrackerTraits>\r\n    : public TrackingRecHit2DHeterogeneousT<cms::cudacompat::GPUTraits, TrackerTraits> {\r\npublic:\r\n  using TrackingRecHit2DHeterogeneousT<cms::cudacompat::GPUTraits, TrackerTraits>::TrackingRecHit2DHeterogeneousT;\r\n  cms::cuda::host::unique_ptr<float[]> localCoordToHostAsync(cudaStream_t stream) const;\r\n  cms::cuda::host::unique_ptr<uint32_t[]> hitsModuleStartToHostAsync(cudaStream_t stream) const;\r\n  cms::cuda::host::unique_ptr<uint16_t[]> store16ToHostAsync(cudaStream_t stream) const;\r\n  cms::cuda::host::unique_ptr<float[]> store32ToHostAsync(cudaStream_t stream) const;\r\n};\r\n\r\n```\r\n\r\nand for which we may define the needed alias:\r\n\r\n```Cpp\r\ntemplate <typename TrackerTraits>\r\nusing TrackingRecHit2DGPUT = TrackingRecHit2DGPUBaseT<cms::cudacompat::GPUTraits, TrackerTraits>;\r\n```\r\n\r\nNote that the primary template class specializations defined in `TrackingRecHit2DHeterogeneous.cc` such as \r\n\r\n```Cpp\r\ntemplate <typename Traits, typename TrackerTraits>\r\ncms::cuda::host::unique_ptr<float[]> TrackingRecHit2DHeterogeneousT<Traits, TrackerTraits>::localCoordToHostAsync(\r\n    cudaStream_t stream) const {\r\n  if constexpr (std::is_same_v<Traits, cms::cudacompat::GPUTraits>) {\r\n    auto ret = cms::cuda::make_host_unique<float[]>(5 * this->nHits(), stream);\r\n    cms::cuda::copyAsync(ret, this->m_store32, 5 * this->nHits(), stream);\r\n    return ret;\r\n  } else {\r\n    static_assert(true, \"Intended to be used only with GPU traits.\\n\");\r\n    return nullptr;\r\n  }\r\n}\r\n```\r\n\r\nare needed since they are used in the base constructor and if not explicilty defined the linker doesn't see them.\r\n\r\nAnother solution would be to have an extra accessor struct in the class to partially specialize only that\r\n(as StackOverflow suggest [here](https://stackoverflow.com/questions/165101/invalid-use-of-incomplete-type-error-with-partial-template-specialization)) but it seems to me more messy than this.\r\n\r\nThe same reasoning applies to `CAHitNtupletGeneratorKernels`.\r\n\r\n### CA params: selections and cuts\r\n\r\nIn order to have possibly different cuts and selections in cell, tuple and track building and selecting the `Params` struct used in `CAHitNtupletGeneratorKernels` has been split in \r\n\r\n- `AlgoParams` that are those that are common to all topologies and act mostly on the configuration of the algorithm itself;\r\n\r\nand some specific to the topology:\r\n\r\n- `CellCutsT` that includes the cuts (parameters and methods) to be applied at doublets buidling level. Note that at the moment this are the same for all the topology but having them separated would allow it to be changed in future.\r\n- `CAParamsT` that include the cuts (parameters and methods) and the ntuplet levels.\r\n- `QualityCutsT` that acts on the track selection and that was already there. It has been moved to `TrackSoAHeterogeneousT` header (that seems more natural) and now the struct itself holds the methods to apply the cuts on the tracks.\r\n\r\nThis (splitting and moving the cuts to be methods of the structs) whould allow to define specific cuts for specific topologies. In order to allow partial specialization and keep common implementation for topologies derived from a base topology, these are wrapped in a `topologyCuts` struct.\r\n\r\n### SimplePixelTopology\r\n\r\nNow the `SimplePixelTopology` holds all the constants that are neede for the pixel tracks reconstruction (so the formerly `CAConstants`, the `gpuPixelDoublets` and the former `SimplePixelTopology` itself) moving the definitions from `namespace`s to `struct`s in order to use them as template parameters.\r\n\r\nNote that some \"helper\" `namespace` have been kept following the discussion here (PR discussion).\r\n\r\nThe \r\n\r\n```Cpp\r\ntemplate <typename T>\r\nusing isPhase1Topology = typename std::enable_if<std::is_base_of<Phase1,T>::value>::type;\r\n\r\ntemplate <typename T>\r\nusing isPhase2Topology = typename std::enable_if<std::is_base_of<Phase2,T>::value>::type;\r\n```\r\n\r\nhave been defined keeping in mind that we may have modifications to `Phase1` and `Phase2` topologies (e.g. for HIon in Run3). Thus by defining new `TrackerTraits` struts that inherits from `Phase1` and `Phase2` and togheter with the `isPhase1Topology` and the `isPhase2Topology` one could:\r\n- define a new topology with minimal code duplication;\r\n- use the same specialized templates (for cuts and selections mainly) without having to add a new one for the modified topology.\r\n\r\nThis is achieved, e.g., the template for `ParamsT` as\r\n\r\n``` Cpp\r\n template <typename TrackerTraits, typename Enable = void>\r\n   struct ParamsT : public AlgoParams\r\n```\r\n\r\nand then specialize it for __all__ the topologies based on `Phase1` as \r\n\r\n```Cpp\r\ntemplate <typename TrackerTraits>\r\n   struct ParamsT<TrackerTraits, isPhase1Topology<TrackerTraits>> : public AlgoParams\r\n``` \r\n\r\n### Rolling fits\r\n\r\nIn `HelixFitOnGPU.h`  the helper \r\n\r\n```Cpp\r\n\r\ntemplate <auto Start, auto End, auto Inc, class F>  //a compile-time bounded for loop\r\n   constexpr void rolling_fits(F &&f) {\r\n     if constexpr (Start < End) {\r\n       f(std::integral_constant<decltype(Start), Start>());\r\n       rolling_fits<Start + Inc, End, Inc>(f);\r\n     }\r\n   }\r\n\r\n```\r\n\r\nis defined to have a \"`constexpr`\" for loop useful to avoid code duplication when running the track fits. In this way, with the help of a lambda function the fits may be unrolled as:\r\n\r\n```Cpp\r\n       riemannFit::rolling_fits<4, TrackerTraits::maxHitsOnTrackForFullFit, 1>(\r\n           [this, &hv, &tkidGPU, &hitsGPU, &hits_geGPU, &fast_fit_resultsGPU, &offset](auto i) {\r\n             kernel_BLFastFit<i, TrackerTraits>(tuples_,\r\n                                                tupleMultiplicity_,\r\n                                                hv,\r\n                                                tkidGPU.get(),\r\n                                                hitsGPU.get(),\r\n                                                hits_geGPU.get(),\r\n                                                fast_fit_resultsGPU.get(),\r\n                                                i,\r\n                                                i,\r\n                                                offset);\r\n\r\n             kernel_BLFit<i, TrackerTraits>(tupleMultiplicity_,\r\n                                            bField_,\r\n                                            outputSoa_,\r\n                                            tkidGPU.get(),\r\n                                            hitsGPU.get(),\r\n                                            hits_geGPU.get(),\r\n                                            fast_fit_resultsGPU.get());\r\n           });\r\n\r\n```\r\n\r\nWith `maxHitsOnTrackForFullFit` a new constant defined to limit the number of hits used in the fit.\r\n\r\n## Run3 Validation\r\n\r\n(with the help of `patatrack-validation` package)\r\n\r\n### Physics \r\n\r\nComparing `12_5_X` (blue) vs `tracker_traits_125` (red).\r\n\r\n\r\n__Dataset__: 1000 events from [/RelValTTbar_14TeV/CMSSW_12_4_0_pre4-PU_124X_mcRun3_2021_realistic_v1-v1/GEN-SIM-DIGI-RAW ](https://cmsweb.cern.ch/das/request?input=dataset%3D%2FRelValTTbar_14TeV%2FCMSSW_12_4_0_pre4-PU_124X_mcRun3_2021_realistic_v1-v1%2FGEN-SIM-DIGI-RAW&instance=prod/global)\r\n\r\n\r\nW.f. `.502` on CPU/GPU:\r\n\r\n- quadruplets on CPU [plots](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/validation_plots_run3/run3_cpu_quads_plots/) \r\n- quadruplets on GPU [plots](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/validation_plots_run3/run3_gpu_quads_plots/) \r\n\r\n\r\nW.f. `.502` on CPU/GPU:\r\n\r\n- triplets on CPU [plots](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/validation_plots_run3/run3_cpu_trips_plots/) \r\n- triplets on GPU [plots](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/validation_plots_run3/run3_gpu_trips_plots/) \r\n\r\n### Throughput\r\n\r\n#### /EphemeralHLTPhysics1/Run2018D-v1/RAW run=323775 lumi=53\r\n\r\nEvaluated on `fu-c2a02-37-01` T4@P5 via `patatrack-scripts`. \r\n\r\n![scan-136.885502.png](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/scan-136_885502.png)\r\n![zoom-136.885502.png](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/zoom-136_885502.png)\r\n\r\n\r\n## Phase2 Performance\r\n\r\n### Physics\r\n\r\n500 TTbar events with <PU>=200 D88 geometry.\r\n\r\n- quadruplets on CPU/GPU [plots](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/phase2_quads_plots/) (i.e. `.502` wf on CPU/GPU)\r\n- triplets on CPU/GPU [plots](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/phase2_trips_plots/) (i.e. `.506` wf on CPU/GPU)\r\n\r\n### Timing\r\n\r\nSee the piechart plots [here](https://adiflori.web.cern.ch/adiflori/circles/web/piechart.php?colours=default&groups=hlt&threshold=0) for triplets or quadruplets on GPU or CPU:\r\n\r\n- `250-350 ms` for quadruplets-triplets on GPU;\r\n- `1.2-1.6s` for quadruplets-triplets on CPU;\r\n\r\nThese numbers would be improved with a finer selection for layer pairs and doublet cuts.\r\n\r\n\r\n### Dependency graphs\r\n\r\nGPU dependency graph\r\n\r\n![gpu_dep](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/gpu_phase2_dep.png)\r\n\r\nCPU dependency graph\r\n\r\n![cpu_dep](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/cpu_phase2_dep.png)\r\n", "branch": "master", "changed_files": 84, "comments": 72, "commits": 7, "created_at": "1657902617", "deletions": 3165, "labels": ["reconstruction-pending", "dqm-pending", "hlt-pending", "geometry-pending", "pending-signatures", "tests-pending", "orp-pending", "code-checks-pending", "heterogeneous-pending", "tracking", "trk"], "milestone": "CMSSW_12_6_X", "number": 38761, "release-notes": [], "review_comments": 56, "state": "open", "title": "Tracker Traits and Enabling Phase2 for Inner Tracker Reconstruction ", "updated_at": "1662709305", "user": "AdrianoDee"}