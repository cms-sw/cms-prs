{"additions": 4317, "auther_ref": "tracker_traits_125", "auther_sha": "5cb46ec039b5f9a707cb8469e457fd2644bd809d", "author": "AdrianoDee", "body": "This PR proposes the addition of a `TrackerTraits` template parameter for all the modules and the datastructres used for pixel tracks reconstruciton. This trait holds all the methods and constants needed to define the pixel tracker topology. Being a template, this would allow to define different datastructure sizes, selection algorithms, fitting features for the whole chain at compile time. In this way one could keep disentangled the different conditions and reconstuction targets (HLT, offline, HIon, Run3, Phase2 ...).\r\n\r\nWith the implementation of such a structure this PR allows to run on GPU (and CPU) the whole Phase2 Inner Tracker reconstruction (from DIGI to pixel Tracks). A following PR will allow this also for offline pixel seeding and offline HIon pixel track reconstruction. \r\n\r\nFind below some comments to the code to (I hope) better navigate it, the validation for run3 pixel tracks w.r.t. to `12_5_X` as it is and the performance for Phase2 IT reconstruction. Few open points are still to be addressed but I would leave them documented in an issue and to be assessed in following PRs.\r\n\r\n- [ ] better tuning for Phase2 layer pairs selection: high impact on timing; \r\n- [ ] better tuning for Phase2 High Purity selection;\r\n- [x] extending the TrackerTraits logic to few RawToDigi methods (such as `clusterChargeCut`, `calibDigisPhase2` ...);\r\n- [x] address CPUvsGPU discrepancies for Phase2;\r\n- [ ] add validation scripts for Phase2 IT reco (local reco and pixel track reco);\r\n- [x] tuning pixel vertex reconstruction (n.b. in the TDR the legacy one was used);\r\n- [x] update Riemann fit also (needed? not actually used in production);\r\n- [x] updating DQM modules such as `SiPixelPhase1CompareTrackSoA` to be runnable also for Phase2.\r\n\r\nThis PR also answers the comments that were left on https://github.com/cms-sw/cmssw/pull/36235 and corrects the pixel digis calibration on gpu (in `gpuCalibPixel.h`) to reproduce what is in `PixelThresholdClusterizer.cc`. This implies changes in the constants to be used moved to\r\n\r\n```Cpp\r\n constexpr float ElectronPerADCGain = 1500;\r\n constexpr uint16_t Phase2DigiBaseline = 1000;\r\n```\r\n\r\nand in `Phase2KinkADC` usage in the calibration. See the original algorithm (in [PixelThresholdClusterizer](https://cmssdt.cern.ch/dxr/CMSSW/source/RecoLocalTracker/SiPixelClusterizer/plugins/PixelThresholdClusterizer.cc#338)) and the parameter sets used (in [phase2TrackerDigitizer_cfi](https://cmssdt.cern.ch/dxr/CMSSW/source/SimTracker/SiPhase2Digitizer/python/phase2TrackerDigitizer_cfi.py#3) and [SiPixelClusterizer_cfi](https://cmssdt.cern.ch/dxr/CMSSW/source/RecoLocalTracker/SiPixelClusterizer/python/SiPixelClusterizer_cfi.py#33))\r\n## Code comments\r\n\r\n### \"Backward\" compatibility\r\n\r\nThis has been solved by https://github.com/cms-sw/cmssw/pull/38806.\r\n\r\n### Partial specialization\r\n\r\nThis has been simplified during the review.\r\n\r\n### CA params: selections and cuts\r\n\r\nIn order to have possibly different cuts and selections in cell, tuple and track building and selecting the `Params` struct used in `CAHitNtupletGeneratorKernels` has been split in \r\n\r\n- `AlgoParams` that are those that are common to all topologies and act mostly on the configuration of the algorithm itself;\r\n\r\nand some specific to the topology:\r\n\r\n- `CellCutsT` that includes the cuts (parameters and methods) to be applied at doublets buidling level. Note that at the moment this are the same for all the topology but having them separated would allow it to be changed in future.\r\n- `CAParamsT` that include the cuts (parameters and methods) and the ntuplet levels.\r\n- `QualityCutsT` that acts on the track selection and that was already there. It has been moved to `TrackSoAHeterogeneousT` header (that seems more natural) and now the struct itself holds the methods to apply the cuts on the tracks.\r\n\r\nThis (splitting and moving the cuts to be methods of the structs) whould allow to define specific cuts for specific topologies. In order to allow partial specialization and keep common implementation for topologies derived from a base topology, these are wrapped in a `topologyCuts` struct.\r\n\r\n### SimplePixelTopology\r\n\r\nNow the `SimplePixelTopology` holds all the constants that are neede for the pixel tracks reconstruction (so the formerly `CAConstants`, the `gpuPixelDoublets` and the former `SimplePixelTopology` itself) moving the definitions from `namespace`s to `struct`s in order to use them as template parameters.\r\n\r\nNote that some \"helper\" `namespace` have been kept following the discussion here (PR discussion).\r\n\r\nThe \r\n\r\n```Cpp\r\ntemplate <typename T>\r\nusing isPhase1Topology = typename std::enable_if<std::is_base_of<Phase1,T>::value>::type;\r\n\r\ntemplate <typename T>\r\nusing isPhase2Topology = typename std::enable_if<std::is_base_of<Phase2,T>::value>::type;\r\n```\r\n\r\nhave been defined keeping in mind that we may have modifications to `Phase1` and `Phase2` topologies (e.g. for HIon in Run3). Thus by defining new `TrackerTraits` struts that inherits from `Phase1` and `Phase2` and togheter with the `isPhase1Topology` and the `isPhase2Topology` one could:\r\n- define a new topology with minimal code duplication;\r\n- use the same specialized templates (for cuts and selections mainly) without having to add a new one for the modified topology.\r\n\r\nThis is achieved, e.g., the template for `ParamsT` as\r\n\r\n``` Cpp\r\n template <typename TrackerTraits, typename Enable = void>\r\n   struct ParamsT : public AlgoParams\r\n```\r\n\r\nand then specialize it for __all__ the topologies based on `Phase1` as \r\n\r\n```Cpp\r\ntemplate <typename TrackerTraits>\r\n   struct ParamsT<TrackerTraits, isPhase1Topology<TrackerTraits>> : public AlgoParams\r\n``` \r\n\r\n### Rolling fits\r\n\r\nIn `HelixFitOnGPU.h`  the helper \r\n\r\n```Cpp\r\n\r\ntemplate <auto Start, auto End, auto Inc, class F>  //a compile-time bounded for loop\r\n   constexpr void rolling_fits(F &&f) {\r\n     if constexpr (Start < End) {\r\n       f(std::integral_constant<decltype(Start), Start>());\r\n       rolling_fits<Start + Inc, End, Inc>(f);\r\n     }\r\n   }\r\n\r\n```\r\n\r\nis defined to have a \"`constexpr`\" for loop useful to avoid code duplication when running the track fits. In this way, with the help of a lambda function the fits may be unrolled as:\r\n\r\n```Cpp\r\n       riemannFit::rolling_fits<4, TrackerTraits::maxHitsOnTrackForFullFit, 1>(\r\n           [this, &hv, &tkidGPU, &hitsGPU, &hits_geGPU, &fast_fit_resultsGPU, &offset](auto i) {\r\n             kernel_BLFastFit<i, TrackerTraits>(tuples_,\r\n                                                tupleMultiplicity_,\r\n                                                hv,\r\n                                                tkidGPU.get(),\r\n                                                hitsGPU.get(),\r\n                                                hits_geGPU.get(),\r\n                                                fast_fit_resultsGPU.get(),\r\n                                                i,\r\n                                                i,\r\n                                                offset);\r\n\r\n             kernel_BLFit<i, TrackerTraits>(tupleMultiplicity_,\r\n                                            bField_,\r\n                                            outputSoa_,\r\n                                            tkidGPU.get(),\r\n                                            hitsGPU.get(),\r\n                                            hits_geGPU.get(),\r\n                                            fast_fit_resultsGPU.get());\r\n           });\r\n\r\n```\r\n\r\nWith `maxHitsOnTrackForFullFit` a new constant defined to limit the number of hits used in the fit.\r\n\r\n-----\r\n### Phase2\r\n\r\n#### Physics validation \r\n\r\nQuadruplets:\r\n- [CPU vs CPU](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks_latest/phase2_plots/quadruplets/)\r\n\r\nTriplets:\r\n- [CPU vs CPU](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks_latest/phase2_plots/triplets/)\r\n\r\n-----\r\n### Run3\r\n\r\n#### Physics validation \r\n\r\nQuadruplets:\r\n- [CPU](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks_latest/run3_cpu_quads_plots/)\r\n- [GPU](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks_latest/run3_gpu_quads_plots/)\r\n\r\nTriplets:\r\n- [CPU](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks_latest/run3_cpu_trips_plots/)\r\n- [GPU](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks_latest/run3_gpu_trips_plots/)\r\n\r\n\r\n### Throughput \r\n\r\n`/EphemeralHLTPhysics1/Run2018D-v1/RAW run=323775 lumi=53`\r\n\r\nEvaluated on `fu-c2a02-37-02` T4@P5 via patatrack-scripts.\r\n\r\n**There's a gain of 7-9%**\r\n\r\n![](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks_latest/scan-136.885502.png)\r\n\r\n\r\n![](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks_latest/zoom-136.885502.png)\r\n\r\n### Dependency graphs\r\n\r\nGPU dependency graph\r\n\r\n![gpu_dep](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/gpu_phase2_dep.png)\r\n\r\nCPU dependency graph\r\n\r\n![cpu_dep](https://adiflori.web.cern.ch/adiflori/upgrade_patatracks/cpu_phase2_dep.png)\r\n", "branch": "master", "changed_files": 84, "closed_at": "1669823703", "comments": 169, "commits": 8, "created_at": "1657902617", "deletions": 3172, "labels": ["dqm-approved", "geometry-approved", "hlt-approved", "reconstruction-approved", "fully-signed", "tests-started", "orp-approved", "code-checks-approved", "heterogeneous-approved", "tracking", "trk"], "merge_commit_sha": "e338d2898258ced2daabea67eaa710e8dcdd96f4", "merged_at": "1669823703", "merged_by": "cmsbuild", "milestone": "CMSSW_13_0_X", "number": 38761, "release-notes": [], "review_comments": 71, "state": "closed", "title": "Tracker Traits and Enabling Phase2 for Inner Tracker Reconstruction on GPU", "updated_at": "1707927441", "user": "AdrianoDee"}