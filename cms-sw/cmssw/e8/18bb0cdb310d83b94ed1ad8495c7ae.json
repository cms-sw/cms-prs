{"additions": 1, "auther_ref": "iarspider-patch-20240722-2", "auther_sha": "9ba65d806635def47d5d2f252b2f9c192fde540d", "author": "iarspider", "body": "#### PR description:\r\n\r\nFix clang warnings:\r\n\r\n```\r\n src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:239:71: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   239 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(vint_c, false) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  240 |                    intConsumerRev.indexFrom(intConsumerRev.m_tokens[0], edm::InEvent, typeID_vint));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:241:75: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   241 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(vint_blank, false) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  242 |                    intConsumerRev.indexFrom(intConsumerRev.m_tokens[1], edm::InEvent, typeID_vint));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:266:78: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   266 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(vint_c_no_proc, true) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  267 |                    intConsumer.indexFrom(intConsumer.m_tokens[1], edm::InEvent, typeID_vint));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:268:83: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   268 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(vint_blank_no_proc, false) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  269 |                    intConsumer.indexFrom(intConsumer.m_tokens[0], edm::InEvent, typeID_vint));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:362:70: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   362 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(v_int, false) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  363 |                    consumer.indexFrom(consumer.m_tokens[0], edm::InEvent, typeID_int));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:364:73: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   364 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(v_simple, false) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  365 |                    consumer.indexFrom(consumer.m_tokens[1], edm::InEvent, typeID_Simple));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:391:78: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   391 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(v_int_no_proc, false) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  392 |                    consumer.indexFrom(consumer.m_tokens[0], edm::InEvent, typeID_int));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:393:80: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   393 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(v_simple_no_proc, true) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  394 |                    consumer.indexFrom(consumer.m_tokens[1], edm::InEvent, typeID_Simple));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:473:71: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   473 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(vint_c, false) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  474 |                    consumer.indexFrom(consumer.m_tokens[1], edm::InEvent, typeID_vint));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:475:75: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   475 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(vint_blank, false) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  476 |                    consumer.indexFrom(consumer.m_tokens[0], edm::InEvent, typeID_vint));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:562:78: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   562 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(vint_c_no_proc, true) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  563 |                    consumer.indexFrom(consumer.m_mayTokens[1], edm::InEvent, typeID_vint));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n  src/FWCore/Framework/test/edconsumerbase_t.cppunit.cc:564:83: warning: ISO C++20 considers use of overloaded operator '==' (with operand types 'edm::ProductResolverIndexAndSkipBit' and 'ProductResolverIndexAndSkipBit') to be ambiguous despite there being a unique best viable function [-Wambiguous-reversed-operator]\r\n   564 |     CPPUNIT_ASSERT(edm::ProductResolverIndexAndSkipBit(vint_blank_no_proc, false) ==\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^\r\n  565 |                    consumer.indexFrom(consumer.m_mayTokens[0], edm::InEvent, typeID_vint));\r\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/data/cmsbld/jenkins/workspace/build-any-ib/w/el8_amd64_gcc12/external/cppunit/1.15.x-fb84a4bbf5a436317d208e3ef0864e91/include/cppunit/TestAssert.h:274:37: note: expanded from macro 'CPPUNIT_ASSERT'\r\n  274 |   ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \\\r\n      |                                     ^~~~~~~~~\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: ambiguity is between a regular call to this operator and a call with the argument order reversed\r\n   38 |     bool operator==(ProductResolverIndexAndSkipBit const& r) { return value_ == r.value_; }\r\n      |          ^\r\nsrc/FWCore/Framework/interface/ProductResolverIndexAndSkipBit.h:38:10: note: mark 'operator==' as const or add a matching 'operator!=' to resolve the ambiguity\r\n```\r\n\r\n#### PR validation:\r\n\r\nBot tests", "branch": "master", "changed_files": 1, "comments": 2, "commits": 1, "created_at": "1721636101", "deletions": 1, "labels": ["core-pending", "pending-signatures", "orp-pending", "tests-started", "code-checks-pending"], "milestone": "CMSSW_14_1_X", "number": 45523, "release-notes": [], "review_comments": 0, "state": "open", "title": "[clang][cpp20] Fix ambiguous-reversed-operator in ProductResolverIndexAndSkipBit", "updated_at": "1721636124", "user": "iarspider"}