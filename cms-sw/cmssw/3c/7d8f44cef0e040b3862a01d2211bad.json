{"additions": 2, "auther_ref": "fix-clang-CondFormats-DTObjects", "auther_sha": "60d53d54ec326d3e03936aa972ab3dc0d322e0b7", "author": "davidlt", "body": "The patch makes code be a bit more consistent and resolves issue with\nClang compiler. Looking at libstdc++ implemention:\n\n```\n 292   /// Partial specialization for pointer types.\n 293   template<typename _Tp>\n 294     struct atomic<_Tp*>\n\n 308       operator __pointer_type() const noexcept\n 309       { return __pointer_type(_M_b); }\n 310\n 311       operator __pointer_type() const volatile noexcept\n 312       { return __pointer_type(_M_b); }\n```\n\nThere are two conversion functions from `std::atomic<T*>` which causes\nambiguity in implicit conversion to a pointer type.\n\nUse `std::atomic<T*>.load()` as in above function to avoid this issue.\n\nSigned-off-by: David Abdurachmanov David.Abdurachmanov@cern.ch\n", "branch": "CMSSW_7_4_X", "changed_files": 1, "closed_at": "1423143529", "comments": 9, "commits": 1, "created_at": "1423054119", "deletions": 2, "labels": ["alca-approved", "comparison-available", "db-pending", "pending-signatures", "tests-approved"], "merge_commit_sha": "c6ed54d5d68da83a888b6bdfa6283711916d8963", "merged_at": "1423143528", "merged_by": "davidlange6", "milestone": "Next CMSSW_7_4_X", "number": 7556, "release-notes": [], "review_comments": 0, "state": "closed", "title": "CondFormats/DTObjects: fix std::atomic usage with Clang", "updated_at": "1423143529", "user": "davidlt"}