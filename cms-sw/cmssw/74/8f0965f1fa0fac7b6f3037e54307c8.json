{"additions": 86, "auther_ref": "fc-extender", "auther_sha": "0f3bf011ea7c75c40d880b49224e1e4eb8c992d6", "author": "fabiocos", "body": "#### PR description:\r\n\r\nThis PR proposes an update of ```TrackExtenderWithMTD``` following the presentation at the TRK POG meeting https://indico.cern.ch/event/1108413/contributions/4662751/attachments/2373693/4054455/TRK_MTD_20220117.pdf and the following discussion. \r\n\r\nAbout 1/3 of the time used by this module is taken by retrieving the ```Trajectory``` for a given general track using the ```TrackTransformer```, see https://cms-reco-profiling.web.cern.ch/cms-reco-profiling/cgi-bin/igprof-navigator/releases/CMSSW_12_2_0_pre3/34834.21/step3/cpu_endjob/92 . This can be avoided by reusing the ```Trajectory``` optionally stored in a transient form into the event by the iterative tracking, an option by default disabled. \r\nOf course this comes at some cost in memory usage, which should be balanced with the CPU gain benefit.\r\n\r\nThe activation of the flags to save the trajectories in the event if made only for the selection of modules entering into the definition of the ```generalTracks``` output, which at present constitutes the input of the ```TrackExtenderWithMTD```\r\n\r\n#### PR validation:\r\n\r\nTests have been done using the benchmark workflow 34834.21 (D76 scenario TTbar with PU, prod-like), using a home-made MinBias pile-up sample of 10k events. A simple memory and CPU profiling (single stream mode) on 100 events shows a gain in CPU:\r\n\r\n```\r\nTimeReport> Time report complete in 5809.45 seconds\r\n Time Summary: \r\n - Min event:   34.1598\r\n - Max event:   83.5143\r\n - Avg event:   55.9624\r\n - Total loop:  5753.35\r\n - Total init:  55.8676\r\n - Total job:   5809.45\r\n - EventSetup Lock: 0\r\n - EventSetup Get:  0\r\n Event Throughput: 0.0173812 ev/s\r\n CPU Summary: \r\n - Total loop:     5633.37\r\n - Total init:     30.6902\r\n - Total extra:    0\r\n - Total children: 0.184089\r\n - Total job:      5664.15\r\n Processing Summary: \r\n - Number of Events:  100\r\n - Number of Global Begin Lumi Calls:  1\r\n - Number of Global Begin Run Calls: 1\r\n```\r\n\r\nvs previous\r\n\r\n```\r\nTimeReport> Time report complete in 6020.16 seconds\r\n Time Summary: \r\n - Min event:   32.6102\r\n - Max event:   85.8682\r\n - Avg event:   57.9717\r\n - Total loop:  5935.13\r\n - Total init:  84.8239\r\n - Total job:   6020.16\r\n - EventSetup Lock: 0\r\n - EventSetup Get:  0\r\n Event Throughput: 0.0168488 ev/s\r\n CPU Summary: \r\n - Total loop:     5861.23\r\n - Total init:     34.564\r\n - Total extra:    0\r\n - Total children: 0.168424\r\n - Total job:      5895.85\r\n Processing Summary: \r\n - Number of Events:  100\r\n - Number of Global Begin Lumi Calls:  1\r\n - Number of Global Begin Run Calls: 1\r\n```\r\n\r\nwith similar CPU load in both tests, and an extra memory load quantified in about 5%:\r\n\r\n```\r\nMemoryReport> Peak virtual size 6426.03 Mbytes\r\n Key events increasing vsize: \r\n[0] run: 0 lumi: 0 event: 0  vsize = 0 deltaVsize = 0 rss = 0 delta = 0\r\n[1] run: 1 lumi: 1 event: 1  vsize = 5458.03 deltaVsize = 0 rss = 3278.55 delta = 0\r\n[2] run: 1 lumi: 1 event: 2  vsize = 5970.03 deltaVsize = 512 rss = 3375.28 delta = 96.7305\r\n[7] run: 1 lumi: 1 event: 7  vsize = 6426.03 deltaVsize = 456 rss = 3375.51 delta = 0.234375\r\n[0] run: 0 lumi: 0 event: 0  vsize = 0 deltaVsize = 0 rss = 0 delta = 0\r\n[9] run: 1 lumi: 1 event: 9  vsize = 6426.03 deltaVsize = 0 rss = 3393.05 delta = 17.5352\r\n[8] run: 1 lumi: 1 event: 8  vsize = 6426.03 deltaVsize = 0 rss = 3178.45 delta = -197.059\r\n[7] run: 1 lumi: 1 event: 7  vsize = 6426.03 deltaVsize = 456 rss = 3375.51 delta = 0.234375\r\n```\r\n\r\nvs previous\r\n\r\n```\r\nMemoryReport> Peak virtual size 6418.28 Mbytes\r\n Key events increasing vsize: \r\n[1] run: 1 lumi: 1 event: 1  vsize = 5458.28 deltaVsize = 0 rss = 3093.7 delta = 0\r\n[7] run: 1 lumi: 1 event: 7  vsize = 5906.28 deltaVsize = 448 rss = 3178.19 delta = 84.4922\r\n[19] run: 1 lumi: 1 event: 19  vsize = 6418.28 deltaVsize = 512 rss = 3202.4 delta = 24.207\r\n[0] run: 0 lumi: 0 event: 0  vsize = 0 deltaVsize = 0 rss = 0 delta = 0\r\n[0] run: 0 lumi: 0 event: 0  vsize = 0 deltaVsize = 0 rss = 0 delta = 0\r\n[21] run: 1 lumi: 1 event: 21  vsize = 6418.28 deltaVsize = 0 rss = 2888.15 delta = -314.25\r\n[20] run: 1 lumi: 1 event: 20  vsize = 6418.28 deltaVsize = 0 rss = 3077.96 delta = -124.441\r\n[19] run: 1 lumi: 1 event: 19  vsize = 6418.28 deltaVsize = 512 rss = 3202.4 delta = 24.207\r\n```\r\n\r\nAn igprof PERF_TICKS profiling on 10 events shows the expected variation in the internal module CPU use, with the modue weighting now for 2.2% of the total CPU (vs more than 3% previously):\r\n\r\n```\r\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n            2.2  .........     119.17 / 4'386.72     edm::stream::EDProducerAdaptorBase::doEvent(edm::EventTransitionInfo const&, edm::ActivityRegistry*, edm::ModuleCallingContext const*) [16]\r\n[118]       2.2     119.17       1.68 / 117.49     TrackExtenderWithMTDT<std::vector<reco::Track, std::allocator<reco::Track> > >::produce(edm::Event&, edm::EventSetup const&)\r\n            0.8  .........      44.98 / 59.01        TrackTransformer::transform(reco::TransientTrack const&, std::vector<std::shared_ptr<TrackingRecHit const>, std::allocator<std::shared_ptr<TrackingRecHit const> > >&) const [187]\r\n            0.5  .........      29.13 / 29.13        TrackExtenderWithMTDT<std::vector<reco::Track, std::allocator<reco::Track> > >::tryETLLayers(TrajectoryStateOnSurface const&, Trajectory const&, float, float, (anonymous namespace)::TrackSegments const&, edmNew::DetSetVector<MTDTrackingRecHit> const&, MTDDetLayerGeometry const*, MagneticField const*, Propagator const*, reco::BeamSpot const&, float, bool, (anonymous namespace)::MTDHitMatchingInfo&) const [clone .constprop.0] [344]\r\n            0.3  .........      15.16 / 15.16        TrackExtenderWithMTDT<std::vector<reco::Track, std::allocator<reco::Track> > >::buildTrack(reco::Track const&, Trajectory const&, Trajectory const&, reco::BeamSpot const&, MagneticField const*, Propagator const*, bool, float&, float&, float&, float&, float&, float&) const [926]\r\n            0.2  .........       9.94 / 15.63        (anonymous namespace)::trackPathLength(Trajectory const&, TrajectoryStateClosestToBeamLine const&, Propagator const*, float&, (anonymous namespace)::TrackSegments&) [833]\r\n            0.1  .........       7.55 / 16.30        (anonymous namespace)::getTrajectoryStateClosestToBeamLine(Trajectory const&, reco::BeamSpot const&, Propagator const*, TrajectoryStateClosestToBeamLine&) [676]\r\n            0.0  .........       2.27 / 31.25        TrackExtenderWithMTDT<std::vector<reco::Track, std::allocator<reco::Track> > >::fillMatchingHits(DetLayer const*, TrajectoryStateOnSurface const&, Trajectory const&, float, float, (anonymous namespace)::TrackSegments const&, edmNew::DetSetVector<MTDTrackingRecHit> const&, Propagator const*, reco::BeamSpot const&, float const&, bool, std::vector<std::shared_ptr<TrackingRecHit const>, std::allocator<std::shared_ptr<TrackingRecHit const> > >&, (anonymous namespace)::MTDHitMatchingInfo&) const [325]\r\n            0.0  .........       1.91 / 2.11         TrackTransformer::getTransientRecHits(reco::TransientTrack const&) const [2341]\r\n            0.0  .........       0.90 / 58.40        std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() [190]\r\n            0.0  .........       0.88 / 0.91         Traj2TrackHits::operator()(Trajectory const&, edm::OwnVector<TrackingRecHit, edm::ClonePolicy<TrackingRecHit> >&, std::vector<LocalTrajectoryParameters, std::allocator<LocalTrajectoryParameters> >&, std::vector<unsigned char, std::allocator<unsigned char> >&) const [3214]\r\n            0.0  .........       0.54 / 0.54         TrackExtenderWithMTDT<std::vector<reco::Track, std::allocator<reco::Track> > >::buildTrackExtra(Trajectory const&) const [3891]\r\n            0.0  .........       0.52 / 1.04         edm::AssociationMap<edm::OneToOne<std::vector<Trajectory, std::allocator<Trajectory> >, std::vector<reco::Track, std::allocator<reco::Track> >, unsigned short> >::get(unsigned long) const [3050]\r\n            0.0  .........       0.49 / 0.49         void std::vector<reco::TrackExtra, std::allocator<reco::TrackExtra> >::_M_realloc_insert<reco::TrackExtra>(__gnu_cxx::__normal_iterator<reco::TrackExtra*, std::vector<reco::TrackExtra, std::allocator<reco::TrackExtra> > >, reco::TrackExtra&&) [4043]\r\n            0.0  .........       0.40 / 0.95         reco::HitPattern::appendHit(TrackingRecHit const&, TrackerTopology const&) [3147]\r\n            0.0  .........       0.33 / 5.01         reco::TransientTrack::TransientTrack(edm::Ref<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track, edm::refhelper::FindUsingAdvance<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track> > const&, MagneticField const*, edm::ESHandle<GlobalTrackingGeometry> const&) [1721]\r\n            0.0  .........       0.33 / 0.34         non-virtual thunk to reco::TrackTransientTrack::outermostMeasurementState() const [4570]\r\n            0.0  .........       0.30 / 0.30         std::vector<std::shared_ptr<TrackingRecHit const>, std::allocator<std::shared_ptr<TrackingRecHit const> > >::~vector() [4781]\r\n            0.0  .........       0.28 / 114.60       operator delete(void*, unsigned long) [121]\r\n            0.0  .........       0.27 / 0.27         edm::refitem::GetRefPtrImpl<std::vector<Trajectory, std::allocator<Trajectory> >, Trajectory, edm::refhelper::FindUsingAdvance<std::vector<Trajectory, std::allocator<Trajectory> >, Trajectory>, unsigned int>::getRefPtr_(edm::RefCore const&, unsigned int) [4916]\r\n            0.0  .........       0.26 / 2.39         TransientTrackBuilder::build(edm::Ref<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track, edm::refhelper::FindUsingAdvance<std::vector<reco::Track, std::allocator<reco::Track> >, reco::Track> > const&) const [2248]\r\n(...)\r\n```\r\n\r\nThe DQM histogram comparison shows a very moderate difference in the output of MTD tracks and vertices tests, and 4D vertices. Since the code should just replace the ```Trajectory``` from the original track fit with its reconstruction from the ```TrackTransformer``` I would conclude that some possible small difference might be expected there. In any case the overall behaviour of the code looks very well consistent between the two versions, even though not strictly identical.", "branch": "master", "changed_files": 11, "comments": 28, "commits": 4, "created_at": "1643099919", "deletions": 22, "labels": ["reconstruction-pending", "operations-pending", "pending-signatures", "tests-pending", "orp-pending", "upgrade-pending", "code-checks-approved", "trk-dpg-pending"], "milestone": "CMSSW_12_3_X", "number": 36793, "release-notes": [], "review_comments": 7, "state": "open", "title": "MTD reconstruction: speed up TrackExtenderWithMTD", "updated_at": "1643640556", "user": "fabiocos"}