{"additions": 561, "auther_ref": "devel_nonIntTriggerPrescales", "auther_sha": "9d3f0c13f596b432b0f056e367c629da76d84b7b", "author": "missirol", "body": "#### PR description:\r\n\r\n#32741 introduced the use fractional L1T prescales [1], as well as support for them in HLT utilities [2].\r\n\r\n[1] Here, \"fractional\" means a number corresponding to `N / 100`, where N is non-negative integer.\r\n[2] This mainly concerns `HLTConfigProvider` and `HLTPrescaleProvider`, which are used by many modules downstream of HLT to access the values of both L1T and HLT prescales.\r\n\r\nOn the other hand, the default template arguments of some methods in [2] still lead to using integers for both L1T and HLT prescales. This can lead to silent truncation of non-integer L1T prescales in client code (in principle, this would also apply to HLT prescales, but non-integer HLT prescales have never been used, to my knowledge; conversely, fractional L1T prescales have been used to take data since a while now).\r\n\r\nThis PR (1) deprecates the use of types other than `double` and `FractionalPrescale` for accessing L1T and HLT prescales via `HLTConfigProvider` and `HLTPrescaleProvider`, and (2) updates client code in CMSSW. Concerning user code outside CMSSW, (1) will prevent it from compiling if it tries to access L1T or HLT prescales with deprecated types (the solution is to specify the appropriate types as template arguments).\r\n\r\nEdit: this PR was originally dropping support for integers in HLT utilities only for L1T prescales, and this was later extended to HLT prescales as well, with the idea of 'breaking' user code only once for both, in view of the possibility that HLT might use non-integer prescales in the future. See for further details.\r\n\r\nThis PR is alternative to #39094.\r\n\r\nKindly asking @Sam-Harper and @fwyzard to review.\r\n\r\n_Note_ : this PR only takes care of code accessing L1T prescales via `HLTPrescaleProvider`. Clients accessing L1T prescales in other ways [a,b,~~c~~] are not affected (for better or worse) by this PR.\r\n\r\n[a] code accessing L1T prescales directly via `L1GtUtils` (Stage-1 L1T, pre-2016; only supporting `int` for L1T prescale values)\r\n[b] code accessing L1T prescales directly via `L1TGlobalUtil` (Stage-1 L1T, 2016-now; only supporting `double` for L1T prescale values since #32741)\r\n~~[c] code accessing prescales via `PackedTriggerPrescales` (e.g. `int ps = (PackedTriggerPrescales).getPrescaleForName` will continue to silently truncate values).~~\r\n\r\n#### PR validation:\r\n\r\n`scram build runtests` and `runTheMatrix.py -l 11634.0` passed.\r\n\r\n#### If this PR is a backport, please specify the original PR and why you need to backport that PR. If this PR will be backported, please specify to which release cycle the backport is meant for:\r\n\r\nNot sure about backports. In my understanding, client code touched by this PR is accessing L1T prescales in 2022 Data incorrectly, truncating those values to integers, so there might be reasons to backport this to `12_5_X`, or even `12_4_X`. Aside from DQM (and code outside CMSSW), the main downstream effect might be on MINIAOD, because of the update in `PATTriggerProducer` and `DataFormats/PatCandidates`.", "branch": "master", "changed_files": 32, "closed_at": "1663675607", "comments": 58, "commits": 1, "created_at": "1661530996", "deletions": 428, "labels": ["analysis-pending", "alca-approved", "dqm-approved", "hlt-approved", "l1-approved", "reconstruction-approved", "pending-signatures", "tests-approved", "pdmv-approved", "bug-fix", "orp-approved", "urgent", "code-checks-approved", "xpog-approved"], "merge_commit_sha": "44a3367085005441f91a536093c22549a97081e4", "merged_at": "1663675607", "merged_by": "cmsbuild", "milestone": "CMSSW_12_6_X", "number": 39220, "release-notes": [], "review_comments": 39, "state": "closed", "title": "deprecate integer types for L1T and HLT prescales in `HLTConfigData` and its clients", "updated_at": "1663675607", "user": "missirol"}